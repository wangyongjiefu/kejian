<!DOCTYPE  html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="zh" lang="zh"><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"/><title>(08-Promise\265\304\312\271\323\303.pptx)</title><meta name="author" content="lala"/><style type="text/css"> * {margin:0; padding:0; text-indent:0; }
 h1 { color: black; font-family:微软雅黑, sans-serif; font-style: normal; font-weight: bold; text-decoration: none; font-size: 57pt; }
 .s1 { color: #585858; font-family:微软雅黑, sans-serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 15.5pt; }
 .a, a { color: black; font-family:微软雅黑, sans-serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 14pt; }
 .s3 { color: black; font-family:"Times New Roman", serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 10pt; }
 .h2 { color: #3F3F3F; font-family:微软雅黑, sans-serif; font-style: normal; font-weight: bold; text-decoration: none; font-size: 31.5pt; }
 .s4 { color: #F00; font-family:微软雅黑, sans-serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 15.5pt; }
 p { color: #585858; font-family:微软雅黑, sans-serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 14pt; margin:0pt; }
 li {display: block; }
 #l1 {padding-left: 0pt; }
 #l1> li>*:first-child:before {content: " "; color: black; font-family:Wingdings; font-style: normal; font-weight: normal; text-decoration: none; }
 #l2 {padding-left: 0pt; }
 #l2> li>*:first-child:before {content: " "; color: black; font-family:Wingdings; font-style: normal; font-weight: normal; text-decoration: none; }
 #l3 {padding-left: 0pt; }
 #l3> li>*:first-child:before {content: " "; color: black; font-family:Wingdings; font-style: normal; font-weight: normal; text-decoration: none; }
 #l4 {padding-left: 0pt; }
 #l4> li>*:first-child:before {content: " "; color: black; font-family:Wingdings; font-style: normal; font-weight: normal; text-decoration: none; }
 #l5 {padding-left: 0pt; }
 #l5> li>*:first-child:before {content: " "; color: black; font-family:Wingdings; font-style: normal; font-weight: normal; text-decoration: none; }
 #l6 {padding-left: 0pt; }
 #l6> li>*:first-child:before {content: " "; color: black; font-family:Wingdings; font-style: normal; font-weight: normal; text-decoration: none; }
 #l7 {padding-left: 0pt; }
 #l7> li>*:first-child:before {content: " "; color: black; font-family:Wingdings; font-style: normal; font-weight: normal; text-decoration: none; }
 #l8 {padding-left: 0pt; }
 #l8> li>*:first-child:before {content: " "; color: black; font-family:Wingdings; font-style: normal; font-weight: normal; text-decoration: none; }
 #l9 {padding-left: 0pt; }
 #l9> li>*:first-child:before {content: " "; color: black; font-family:Wingdings; font-style: normal; font-weight: normal; text-decoration: none; }
 #l10 {padding-left: 0pt; }
 #l10> li>*:first-child:before {content: " "; color: black; font-family:Wingdings; font-style: normal; font-weight: normal; text-decoration: none; }
 #l11 {padding-left: 0pt; }
 #l11> li>*:first-child:before {content: " "; color: black; font-family:Wingdings; font-style: normal; font-weight: normal; text-decoration: none; }
 #l12 {padding-left: 0pt; }
 #l12> li>*:first-child:before {content: " "; color: #585858; font-family:Wingdings; font-style: normal; font-weight: normal; text-decoration: none; font-size: 14pt; }
 #l13 {padding-left: 0pt; }
 #l13> li>*:first-child:before {content: " "; color: #585858; font-family:Wingdings; font-style: normal; font-weight: normal; text-decoration: none; font-size: 14pt; }
 #l14 {padding-left: 0pt; }
 #l14> li>*:first-child:before {content: " "; color: black; font-family:Wingdings; font-style: normal; font-weight: normal; text-decoration: none; }
 #l15 {padding-left: 0pt; }
 #l15> li>*:first-child:before {content: " "; color: black; font-family:Wingdings; font-style: normal; font-weight: normal; text-decoration: none; }
 #l16 {padding-left: 0pt; }
 #l16> li>*:first-child:before {content: " "; color: black; font-family:Wingdings; font-style: normal; font-weight: normal; text-decoration: none; }
 #l17 {padding-left: 0pt; }
 #l17> li>*:first-child:before {content: " "; color: black; font-family:Wingdings; font-style: normal; font-weight: normal; text-decoration: none; }
</style></head><body><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="text-indent: 0pt;text-align: left;"><span><img width="1117" height="22" alt="image" src="index_files/Image_001.png"/></span></p><h1 style="padding-left: 303pt;text-indent: 0pt;line-height: 95pt;text-align: center;">Promise</h1><p class="s1" style="padding-top: 17pt;padding-left: 303pt;text-indent: 0pt;line-height: 27pt;text-align: center;">王红元</p><p class="s1" style="padding-left: 359pt;text-indent: -9pt;line-height: 90%;text-align: center;"><span>微博：coderwhy<br/>微信：372623326</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 368pt;text-indent: 0pt;text-align: left;"><span><img width="140" height="50" alt="image" src="index_files/Image_002.jpg"/></span></p><p style="text-indent: 0pt;text-align: left;"><span><img width="1117" height="22" alt="image" src="index_files/Image_003.png"/></span></p><p style="padding-left: 303pt;text-indent: 0pt;text-align: center;"><a href="http://www.520it.com/" class="a" target="_blank">实力IT教育 </a><a href="http://www.520it.com/" target="_blank">www.520it.com</a></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="text-indent: 0pt;text-align: left;"><span><img width="1119" height="7" alt="image" src="index_files/Image_004.png"/></span></p><p style="text-indent: 0pt;text-align: left;"/><p class="s3" style="padding-left: 13pt;text-indent: 0pt;line-height: 55pt;text-align: left;"><span><img width="141" height="50" alt="image" src="index_files/Image_005.jpg"/></span>        <span class="h2">什么是Promise呢？</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><ul id="l1"><li><p class="s1" style="padding-top: 1pt;padding-left: 33pt;text-indent: -15pt;line-height: 27pt;text-align: left;">ES6中一个非常重要和好用的特性就是Promise</p><ul id="l2"><li><p class="s1" style="padding-left: 64pt;text-indent: -15pt;line-height: 26pt;text-align: left;">但是初次接触Promise会一脸懵逼，这TM是什么东西？</p></li><li><p class="s1" style="padding-left: 64pt;text-indent: -15pt;line-height: 27pt;text-align: left;">看看官方或者一些文章对它的介绍和用法，也是一头雾水。</p></li></ul></li><li><p class="s1" style="padding-top: 2pt;padding-left: 33pt;text-indent: -15pt;line-height: 27pt;text-align: left;">Promise到底是做什么的呢？</p><ul id="l3"><li><p class="s4" style="padding-left: 64pt;text-indent: -15pt;line-height: 27pt;text-align: left;">Promise是异步编程的一种解决方案<span style=" color: #585858;">。</span></p></li></ul></li><li><p class="s1" style="padding-top: 2pt;padding-left: 33pt;text-indent: -15pt;line-height: 27pt;text-align: left;">那什么时候我们会来处理异步事件呢？</p><ul id="l4"><li><p class="s1" style="padding-left: 64pt;text-indent: -15pt;line-height: 26pt;text-align: left;">一种很常见的场景应该就是网络请求了。</p></li><li><p class="s1" style="padding-left: 64pt;text-indent: -15pt;line-height: 26pt;text-align: left;">我们封装一个网络请求的函数，因为不能立即拿到结果，所以不能像简单的3+4=7一样将结果返回。</p></li><li><p class="s1" style="padding-left: 64pt;text-indent: -15pt;line-height: 26pt;text-align: left;">所以往往我们会传入另外一个函数，在数据请求成功时，将数据通过传入的函数回调出去。</p></li><li><p class="s1" style="padding-left: 64pt;text-indent: -15pt;line-height: 27pt;text-align: left;">如果只是一个简单的网络请求，那么这种方案不会给我们带来很大的麻烦。</p></li></ul></li><li><p class="s1" style="padding-top: 2pt;padding-left: 33pt;text-indent: -15pt;line-height: 27pt;text-align: left;">但是，当网络请求非常复杂时，就会出现回调地狱。</p><p style="text-indent: 0pt;text-align: left;"><span><img width="1119" height="6" alt="image" src="index_files/Image_006.png"/></span></p><ul id="l5"><li><p class="s1" style="padding-left: 64pt;text-indent: -15pt;line-height: 27pt;text-align: left;">OK，我以一个非常夸张的案例来说明。</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="text-indent: 0pt;text-align: left;"><span><img width="1119" height="7" alt="image" src="index_files/Image_007.png"/></span></p><p style="text-indent: 0pt;text-align: left;"/><p class="s3" style="padding-left: 13pt;text-indent: 0pt;line-height: 55pt;text-align: left;"><span><img width="141" height="50" alt="image" src="index_files/Image_008.jpg"/></span>        <span class="h2">网络请求的回调地狱</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p></li></ul></li><li><p style="padding-top: 1pt;padding-left: 33pt;text-indent: -15pt;text-align: left;">我们来考虑下面的场景(有夸张的成分)：</p><ul id="l6"><li><p style="padding-left: 64pt;text-indent: -15pt;text-align: left;">我们需要通过一个url1从服务器加载一个数据data1，data1中包含了下一个请求的url2</p></li><li><p style="padding-left: 64pt;text-indent: -15pt;text-align: left;">我们需要通过data1取出url2，从服务器加载数据data2，data2中包含了下一个请求的url3</p></li><li><p style="padding-left: 64pt;text-indent: -15pt;text-align: left;">我们需要通过data2取出url3，从服务器加载数据data3，data3中包含了下一个请求的url4</p><p style="text-indent: 0pt;text-align: left;"><span><img width="376" height="154" alt="image" src="index_files/Image_009.jpg"/></span></p></li><li><p style="padding-left: 64pt;text-indent: -15pt;text-align: left;">发送网络请求url4，获取最终的数据data4</p><p style="text-indent: 0pt;text-align: left;"><br/></p></li></ul></li><li><p style="padding-left: 33pt;text-indent: -15pt;text-align: left;">上面的代码有什么问题吗？</p><ul id="l7"><li><p style="padding-left: 64pt;text-indent: -15pt;text-align: left;">正常情况下，不会有什么问题，可以正常运行并且获取我们想要的结果。</p></li><li><p style="padding-left: 64pt;text-indent: -15pt;text-align: left;">但是，这样额代码难看而且不容易维护。</p></li><li><p style="padding-left: 64pt;text-indent: -15pt;text-align: left;">我们更加期望的是一种更加优雅的方式来进行这种异步操作。</p></li></ul></li><li><p style="padding-top: 4pt;padding-left: 33pt;text-indent: -15pt;text-align: left;">如何做呢？就是使用Promise。</p><p style="text-indent: 0pt;text-align: left;"><span><img width="1119" height="6" alt="image" src="index_files/Image_010.png"/></span></p><ul id="l8"><li><p style="padding-left: 64pt;text-indent: -15pt;text-align: left;">Promise可以以一种非常优雅的方式来解决这个问题。</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="text-indent: 0pt;text-align: left;"><span><img width="1119" height="7" alt="image" src="index_files/Image_011.png"/></span></p><p style="text-indent: 0pt;text-align: left;"/><p class="s3" style="padding-left: 13pt;text-indent: 0pt;line-height: 55pt;text-align: left;"><span><img width="141" height="50" alt="image" src="index_files/Image_012.jpg"/></span>        <span class="h2">定时器的异步事件</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="text-indent: 0pt;text-align: left;"><span><img width="356" height="117" alt="image" src="index_files/Image_013.jpg"/></span></p></li></ul></li><li><p style="padding-top: 1pt;padding-left: 33pt;text-indent: -15pt;text-align: left;">我们先来看看Promise最基本的语法。</p></li><li><p style="padding-top: 4pt;padding-left: 33pt;text-indent: -15pt;text-align: left;">这里，我们用一个定时器来模拟异步事件：</p><ul id="l9"><li><p style="padding-left: 64pt;text-indent: -15pt;text-align: left;">假设下面的data是从网络上1秒后请求的数据</p></li><li><p style="padding-left: 64pt;text-indent: -15pt;text-align: left;">console.log就是我们的处理方式。</p><p style="text-indent: 0pt;text-align: left;"><span><img width="471" height="284" alt="image" src="index_files/Image_014.jpg"/></span></p></li></ul></li><li><p style="padding-top: 4pt;padding-left: 33pt;text-indent: -15pt;text-align: left;">这是我们过去的处理方式，我们将它换成Promise代码</p></li><li><p style="padding-top: 4pt;padding-left: 33pt;text-indent: -15pt;text-align: left;">这个例子会让我们感觉脱裤放屁，多此一举</p><ul id="l10"><li><p style="padding-top: 3pt;padding-left: 64pt;text-indent: -15pt;line-height: 85%;text-align: left;"><span>首先，下面的Promise代码明显比上面的代码看起来还要复<br/>杂。</span></p></li><li><p style="padding-top: 4pt;padding-left: 64pt;text-indent: -15pt;line-height: 85%;text-align: left;"><span>其次，下面的Promise代码中包含的resolve、reject、then、<br/>catch都是些什么东西？</span></p><p style="text-indent: 0pt;text-align: left;"><span><img width="1119" height="6" alt="image" src="index_files/Image_015.png"/></span></p></li></ul></li><li><p style="padding-top: 8pt;padding-left: 33pt;text-indent: -15pt;line-height: 85%;text-align: left;"><span>我们先不管第一个复杂度的问题，因为这样的一个屁大点的程序<br/>根本看不出来Promise真正的作用。</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="text-indent: 0pt;text-align: left;"><span><img width="1119" height="7" alt="image" src="index_files/Image_016.png"/></span></p><p style="text-indent: 0pt;text-align: left;"/><p class="s3" style="padding-left: 13pt;text-indent: 0pt;line-height: 55pt;text-align: left;"><span><img width="141" height="50" alt="image" src="index_files/Image_017.jpg"/></span>        <span class="h2">定时器异步事件解析</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p></li><li><p style="padding-top: 1pt;padding-left: 33pt;text-indent: -15pt;text-align: left;">我们先来认认真真的读一读这个程序到底做了什么？</p><ul id="l11"><li><p style="padding-left: 64pt;text-indent: -15pt;text-align: left;">new Promise很明显是创建一个Promise对象</p></li><li><p style="padding-left: 64pt;text-indent: -15pt;text-align: left;">小括号中((resolve, reject) =&gt; {})也很明显就是一个函数，而且我们这里用的是之前刚刚学习过的箭头函数。</p><ul id="l12"><li><p style="padding-left: 96pt;text-indent: -15pt;text-align: left;">但是resolve, reject它们是什么呢？</p></li><li><p style="padding-left: 96pt;text-indent: -15pt;text-align: left;">我们先知道一个事实：在创建Promise时，传入的这个箭头函数是固定的（一般我们都会这样写）</p></li><li><p style="padding-left: 96pt;text-indent: -15pt;text-align: left;">resolve和reject它们两个也是函数，通常情况下，我们会根据请求数据的成功和失败来决定调用哪一个。</p></li></ul></li><li><p style="padding-left: 64pt;text-indent: -15pt;text-align: left;">成功还是失败？</p><ul id="l13"><li><p style="padding-left: 96pt;text-indent: -15pt;text-align: left;">如果是成功的，那么通常我们会调用resolve(messsage)，这个时候，我们后续的then会被回调。</p></li><li><p style="padding-left: 96pt;text-indent: -15pt;text-align: left;">如果是失败的，那么通常我们会调用reject(error)，这个时候，我们后续的catch会被回调。</p><p style="text-indent: 0pt;text-align: left;"><span><img width="1119" height="6" alt="image" src="index_files/Image_018.png"/></span></p></li></ul></li></ul></li><li><p style="padding-top: 4pt;padding-left: 33pt;text-indent: -15pt;text-align: left;">OK，这就是Promise最基本的使用了。</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="text-indent: 0pt;text-align: left;"><span><img width="1119" height="7" alt="image" src="index_files/Image_019.png"/></span></p><p style="text-indent: 0pt;text-align: left;"/><p class="s3" style="padding-left: 13pt;text-indent: 0pt;line-height: 55pt;text-align: left;"><span><img width="141" height="50" alt="image" src="index_files/Image_020.jpg"/></span>        <span class="h2">Promise三种状态</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="text-indent: 0pt;text-align: left;"><span><img width="457" height="166" alt="image" src="index_files/Image_021.jpg"/></span></p></li><li><p class="s1" style="padding-top: 6pt;padding-left: 33pt;text-indent: -15pt;line-height: 76%;text-align: left;"><span>首先, 当我们开发中有异步操作时, 就可以给异步操作包装一个<br/>Promise</span></p><ul id="l14"><li><p class="s1" style="padding-left: 64pt;text-indent: -15pt;line-height: 28pt;text-align: left;">异步操作之后会有三种状态</p></li></ul></li><li><p class="s1" style="padding-top: 2pt;padding-left: 33pt;text-indent: -15pt;line-height: 27pt;text-align: left;">我们一起来看一下这三种状态:</p><ul id="l15"><li><p class="s1" style="padding-top: 3pt;padding-left: 64pt;text-indent: -15pt;line-height: 77%;text-align: left;"><span>pending：等待状态，比如正在进行网络请求，或者定时<br/>器没有到时间。</span></p><p style="text-indent: 0pt;text-align: left;"><span><img width="429" height="209" alt="image" src="index_files/Image_022.jpg"/></span></p></li><li><p class="s1" style="padding-top: 4pt;padding-left: 64pt;text-indent: -15pt;line-height: 77%;text-align: left;"><span>fulfill：满足状态，当我们主动回调了resolve时，就处于<br/>该状态，并且会回调.then()</span></p><p style="text-indent: 0pt;text-align: left;"><span><img width="1119" height="6" alt="image" src="index_files/Image_023.png"/></span></p></li><li><p class="s1" style="padding-top: 4pt;padding-left: 64pt;text-indent: -15pt;line-height: 77%;text-align: left;"><span>reject：拒绝状态，当我们主动回调了reject时，就处于该<br/>状态，并且会回调.catch()</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="text-indent: 0pt;text-align: left;"><span><img width="1119" height="7" alt="image" src="index_files/Image_024.png"/></span></p><p style="text-indent: 0pt;text-align: left;"/><p class="s3" style="padding-left: 13pt;text-indent: 0pt;line-height: 55pt;text-align: left;"><span><img width="141" height="50" alt="image" src="index_files/Image_025.jpg"/></span>        <span class="h2">Promise链式调用</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="text-indent: 0pt;text-align: left;"><span><img width="494" height="477" alt="image" src="index_files/Image_026.jpg"/></span></p></li></ul></li><li><p style="padding-top: 4pt;padding-left: 33pt;text-indent: -15pt;line-height: 85%;text-align: left;"><span>我们在看Promise的流程图时，发现无论是then还是catch都可<br/>以返回一个Promise对象。</span></p></li><li><p style="padding-top: 5pt;padding-left: 33pt;text-indent: -15pt;text-align: left;">所以，我们的代码其实是可以进行链式调用的：</p></li><li><p style="padding-top: 7pt;padding-left: 33pt;text-indent: -15pt;line-height: 85%;text-align: left;"><span>这里我们直接通过Promise包装了一下新的数据，将Promise对<br/>象返回了</span></p><ul id="l16"><li><p style="padding-top: 4pt;padding-left: 64pt;text-indent: -15pt;line-height: 85%;text-align: left;"><span>Promise.resovle()：将数据包装成Promise对象，并且在<br/>内部回调resolve()函数</span></p><p style="text-indent: 0pt;text-align: left;"><span><img width="1119" height="6" alt="image" src="index_files/Image_027.png"/></span></p></li><li><p style="padding-top: 4pt;padding-left: 64pt;text-indent: -15pt;line-height: 85%;text-align: left;"><span>Promise.reject()：将数据包装成Promise对象，并且在内<br/>部回调reject()函数</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="text-indent: 0pt;text-align: left;"><span><img width="1119" height="7" alt="image" src="index_files/Image_028.png"/></span></p><p style="text-indent: 0pt;text-align: left;"/><p class="s3" style="padding-left: 13pt;text-indent: 0pt;line-height: 55pt;text-align: left;"><span><img width="141" height="50" alt="image" src="index_files/Image_029.jpg"/></span>        <span class="h2">链式调用简写</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="text-indent: 0pt;text-align: left;"><span><img width="491" height="491" alt="image" src="index_files/Image_030.jpg"/></span></p></li></ul></li><li><p style="padding-top: 1pt;padding-left: 33pt;text-indent: -15pt;text-align: left;">简化版代码：</p><ul id="l17"><li><p style="padding-top: 3pt;padding-left: 64pt;text-indent: -15pt;line-height: 85%;text-align: left;"><span>如果我们希望数据直接包装成Promise.resolve，那么在<br/>then中可以直接返回数据</span></p></li><li><p style="padding-top: 4pt;padding-left: 64pt;text-indent: -15pt;line-height: 85%;text-align: left;"><span>注意下面的代码中，我讲return Promise.resovle(data)改<br/>成了return data</span></p><p style="text-indent: 0pt;text-align: left;"><span><img width="1119" height="6" alt="image" src="index_files/Image_031.png"/></span></p></li><li><p style="padding-top: 1pt;padding-left: 64pt;text-indent: -15pt;text-align: left;">结果依然是一样的</p></li></ul></li></ul></body></html>
