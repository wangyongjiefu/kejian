<!DOCTYPE  html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="zh" lang="zh"><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"/><title>(08-Vuex\317\352\275\342.pptx)</title><meta name="author" content="lala"/><style type="text/css"> * {margin:0; padding:0; text-indent:0; }
 h1 { color: black; font-family:微软雅黑, sans-serif; font-style: normal; font-weight: bold; text-decoration: none; font-size: 57pt; }
 .s1 { color: #585858; font-family:微软雅黑, sans-serif; font-style: normal; font-weight: bold; text-decoration: none; font-size: 6pt; }
 .a, a { color: black; font-family:微软雅黑, sans-serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 14pt; }
 .h2, h2 { color: black; font-family:微软雅黑, sans-serif; font-style: normal; font-weight: bold; text-decoration: none; font-size: 31.5pt; }
 .s3 { color: #585858; font-family:微软雅黑, sans-serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 13pt; }
 .s4 { color: #585858; font-family:微软雅黑, sans-serif; font-style: normal; font-weight: bold; text-decoration: none; font-size: 13pt; }
 .s7 { color: #0562C1; font-family:微软雅黑, sans-serif; font-style: normal; font-weight: normal; text-decoration: underline; font-size: 13pt; }
 p { color: #585858; font-family:微软雅黑, sans-serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 15.5pt; margin:0pt; }
 .s8 { color: black; font-family:"Times New Roman", serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 10pt; }
 .s9 { color: #585858; font-family:微软雅黑, sans-serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 14.5pt; }
 .s11 { color: black; font-family:微软雅黑, sans-serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 10pt; }
 .s12 { color: #585858; font-family:微软雅黑, sans-serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 14pt; }
 .s13 { color: black; font-family:微软雅黑, sans-serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 10pt; vertical-align: 8pt; }
 h4 { color: #585858; font-family:微软雅黑, sans-serif; font-style: normal; font-weight: bold; text-decoration: none; font-size: 14pt; }
 .s14 { color: black; font-family:宋体; font-style: normal; font-weight: normal; text-decoration: none; font-size: 15.5pt; }
 .s15 { color: black; font-family:Calibri, sans-serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 15.5pt; }
 li {display: block; }
 #l1 {padding-left: 0pt; }
 #l1> li>*:first-child:before {content: " "; color: black; font-family:Wingdings; font-style: normal; font-weight: normal; text-decoration: none; }
 #l2 {padding-left: 0pt; }
 #l2> li>*:first-child:before {content: " "; color: black; font-family:Wingdings; font-style: normal; font-weight: normal; text-decoration: none; }
 #l3 {padding-left: 0pt; }
 #l3> li>*:first-child:before {content: " "; color: black; font-family:Wingdings; font-style: normal; font-weight: normal; text-decoration: none; }
 #l4 {padding-left: 0pt; }
 #l4> li>*:first-child:before {content: " "; color: black; font-family:Wingdings; font-style: normal; font-weight: normal; text-decoration: none; }
 #l5 {padding-left: 0pt; }
 #l5> li>*:first-child:before {content: " "; color: black; font-family:Wingdings; font-style: normal; font-weight: normal; text-decoration: none; }
 #l6 {padding-left: 0pt; }
 #l6> li>*:first-child:before {content: " "; color: black; font-family:Wingdings; font-style: normal; font-weight: normal; text-decoration: none; }
 #l7 {padding-left: 0pt; }
 #l7> li>*:first-child:before {content: " "; color: black; font-family:Wingdings; font-style: normal; font-weight: normal; text-decoration: none; }
 #l8 {padding-left: 0pt; }
 #l8> li>*:first-child:before {content: " "; color: black; font-family:Wingdings; font-style: normal; font-weight: normal; text-decoration: none; }
 #l9 {padding-left: 0pt; }
 #l9> li>*:first-child:before {content: " "; color: black; font-family:Wingdings; font-style: normal; font-weight: normal; text-decoration: none; }
 li {display: block; }
 #l10 {padding-left: 0pt; }
 #l10> li>*:first-child:before {content: " "; color: #585858; font-family:Wingdings; font-style: normal; font-weight: normal; text-decoration: none; font-size: 15.5pt; }
 #l11 {padding-left: 0pt; }
 #l11> li>*:first-child:before {content: " "; color: black; font-family:Wingdings; font-style: normal; font-weight: normal; text-decoration: none; }
 #l12 {padding-left: 0pt; }
 #l12> li>*:first-child:before {content: " "; color: black; font-family:Wingdings; font-style: normal; font-weight: normal; text-decoration: none; }
 #l13 {padding-left: 0pt; }
 #l13> li>*:first-child:before {content: " "; color: black; font-family:Wingdings; font-style: normal; font-weight: normal; text-decoration: none; }
 #l14 {padding-left: 0pt; }
 #l14> li>*:first-child:before {content: " "; color: black; font-family:Wingdings; font-style: normal; font-weight: normal; text-decoration: none; }
 #l15 {padding-left: 0pt; }
 #l15> li>*:first-child:before {content: " "; color: black; font-family:Wingdings; font-style: normal; font-weight: normal; text-decoration: none; }
 #l16 {padding-left: 0pt; }
 #l16> li>*:first-child:before {content: " "; color: black; font-family:Wingdings; font-style: normal; font-weight: normal; text-decoration: none; }
 #l17 {padding-left: 0pt; }
 #l17> li>*:first-child:before {content: " "; color: black; font-family:Wingdings; font-style: normal; font-weight: normal; text-decoration: none; }
 #l18 {padding-left: 0pt; }
 #l18> li>*:first-child:before {content: " "; color: #585858; font-family:Wingdings; font-style: normal; font-weight: normal; text-decoration: none; font-size: 14.5pt; }
 #l19 {padding-left: 0pt; }
 #l19> li>*:first-child:before {content: " "; color: #585858; font-family:Wingdings; font-style: normal; font-weight: normal; text-decoration: none; font-size: 13pt; }
 #l20 {padding-left: 0pt; }
 #l20> li>*:first-child:before {content: " "; color: #585858; font-family:Wingdings; font-style: normal; font-weight: normal; text-decoration: none; font-size: 14.5pt; }
 #l21 {padding-left: 0pt; }
 #l21> li>*:first-child:before {content: " "; color: black; font-family:Wingdings; font-style: normal; font-weight: normal; text-decoration: none; }
 #l22 {padding-left: 0pt; }
 #l22> li>*:first-child:before {content: " "; color: black; font-family:Wingdings; font-style: normal; font-weight: normal; text-decoration: none; }
 #l23 {padding-left: 0pt; }
 #l23> li>*:first-child:before {content: " "; color: black; font-family:Wingdings; font-style: normal; font-weight: normal; text-decoration: none; }
 #l24 {padding-left: 0pt; }
 #l24> li>*:first-child:before {content: " "; color: black; font-family:Wingdings; font-style: normal; font-weight: normal; text-decoration: none; }
 #l25 {padding-left: 0pt; }
 #l25> li>*:first-child:before {content: " "; color: black; font-family:Wingdings; font-style: normal; font-weight: normal; text-decoration: none; }
 #l26 {padding-left: 0pt; }
 #l26> li>*:first-child:before {content: " "; color: black; font-family:Wingdings; font-style: normal; font-weight: normal; text-decoration: none; }
 #l27 {padding-left: 0pt; }
 #l27> li>*:first-child:before {content: " "; color: black; font-family:Wingdings; font-style: normal; font-weight: normal; text-decoration: none; }
 #l28 {padding-left: 0pt; }
 #l28> li>*:first-child:before {content: " "; color: black; font-family:Wingdings; font-style: normal; font-weight: normal; text-decoration: none; }
 #l29 {padding-left: 0pt; }
 #l29> li>*:first-child:before {content: " "; color: black; font-family:Wingdings; font-style: normal; font-weight: normal; text-decoration: none; }
 #l30 {padding-left: 0pt; }
 #l30> li>*:first-child:before {content: " "; color: black; font-family:Wingdings; font-style: normal; font-weight: normal; text-decoration: none; }
 #l31 {padding-left: 0pt; }
 #l31> li>*:first-child:before {content: " "; color: #585858; font-family:Wingdings; font-style: normal; font-weight: normal; text-decoration: none; font-size: 14pt; }
 #l32 {padding-left: 0pt; }
 #l32> li>*:first-child:before {content: " "; color: black; font-family:Wingdings; font-style: normal; font-weight: normal; text-decoration: none; }
 #l33 {padding-left: 0pt; }
 #l33> li>*:first-child:before {content: " "; color: black; font-family:Wingdings; font-style: normal; font-weight: normal; text-decoration: none; }
 #l34 {padding-left: 0pt; }
 #l34> li>*:first-child:before {content: " "; color: black; font-family:Wingdings; font-style: normal; font-weight: normal; text-decoration: none; }
 #l35 {padding-left: 0pt; }
 #l35> li>*:first-child:before {content: " "; color: black; font-family:Wingdings; font-style: normal; font-weight: normal; text-decoration: none; }
 #l36 {padding-left: 0pt; }
 #l36> li>*:first-child:before {content: " "; color: black; font-family:Wingdings; font-style: normal; font-weight: normal; text-decoration: none; }
 #l37 {padding-left: 0pt; }
 #l37> li>*:first-child:before {content: " "; color: black; font-family:Wingdings; font-style: normal; font-weight: normal; text-decoration: none; }
 #l38 {padding-left: 0pt; }
 #l38> li>*:first-child:before {content: " "; color: black; font-family:Wingdings; font-style: normal; font-weight: normal; text-decoration: none; }
 #l39 {padding-left: 0pt; }
 #l39> li>*:first-child:before {content: " "; color: black; font-family:Wingdings; font-style: normal; font-weight: normal; text-decoration: none; }
 #l40 {padding-left: 0pt; }
 #l40> li>*:first-child:before {content: " "; color: black; font-family:Wingdings; font-style: normal; font-weight: normal; text-decoration: none; }
 #l41 {padding-left: 0pt; }
 #l41> li>*:first-child:before {content: " "; color: black; font-family:Wingdings; font-style: normal; font-weight: normal; text-decoration: none; }
 #l42 {padding-left: 0pt; }
 #l42> li>*:first-child:before {content: " "; color: black; font-family:Wingdings; font-style: normal; font-weight: normal; text-decoration: none; }
 #l43 {padding-left: 0pt; }
 #l43> li>*:first-child:before {content: " "; color: black; font-family:Wingdings; font-style: normal; font-weight: normal; text-decoration: none; }
 #l44 {padding-left: 0pt; }
 #l44> li>*:first-child:before {content: " "; color: black; font-family:Wingdings; font-style: normal; font-weight: normal; text-decoration: none; }
 #l45 {padding-left: 0pt; }
 #l45> li>*:first-child:before {content: " "; color: black; font-family:Wingdings; font-style: normal; font-weight: normal; text-decoration: none; }
 #l46 {padding-left: 0pt; }
 #l46> li>*:first-child:before {content: " "; color: black; font-family:Wingdings; font-style: normal; font-weight: normal; text-decoration: none; font-size: 15.5pt; }
 #l47 {padding-left: 0pt; }
 #l47> li>*:first-child:before {content: " "; color: black; font-family:Wingdings; font-style: normal; font-weight: normal; text-decoration: none; }
</style></head><body><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="text-indent: 0pt;text-align: left;"><span><img width="1117" height="22" alt="image" src="index_files/Image_001.png"/></span></p><h1 style="padding-left: 290pt;text-indent: 0pt;line-height: 95pt;text-align: center;">Vuex详解</h1><p class="s1" style="padding-left: 290pt;text-indent: 0pt;text-align: center;">王红元</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s1" style="padding-left: 395pt;text-indent: 0pt;line-height: 166%;text-align: center;"><span>微博: coderwhy<br/>微信: 372623326</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 368pt;text-indent: 0pt;text-align: left;"><span><img width="140" height="50" alt="image" src="index_files/Image_002.jpg"/></span></p><p style="text-indent: 0pt;text-align: left;"><span><img width="1117" height="22" alt="image" src="index_files/Image_003.png"/></span></p><p style="padding-left: 290pt;text-indent: 0pt;text-align: center;"><a href="http://www.520it.com/" class="a" target="_blank">实力IT教育 </a><a href="http://www.520it.com/" target="_blank">www.520it.com</a></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="text-indent: 0pt;text-align: left;"/><p style="text-indent: 0pt;text-align: left;"><span><img width="1119" height="7" alt="image" src="index_files/Image_004.png"/></span></p><p style="text-indent: 0pt;text-align: left;"><span><img width="141" height="50" alt="image" src="index_files/Image_005.jpg"/></span></p><h2 style="padding-left: 138pt;text-indent: 0pt;line-height: 55pt;text-align: left;">Vuex是做什么的?</h2><p style="text-indent: 0pt;text-align: left;"><br/></p><ul id="l1"><li><p class="s3" style="padding-top: 1pt;padding-left: 35pt;text-indent: -18pt;text-align: left;">官方解释：Vuex 是一个专为 Vue.js 应用程序开发的<b>状态管理模式</b>。</p><ul id="l2"><li><p class="s3" style="padding-top: 3pt;padding-left: 60pt;text-indent: -21pt;text-align: left;">它采用 <span style=" color: #F00;">集中式存储管理 </span>应用的所有组件的状态，并以相应的规则保证状态以一种可预测的方式发生变化。</p></li><li><p class="s3" style="padding-top: 4pt;padding-left: 60pt;text-indent: -21pt;line-height: 92%;text-align: left;">Vuex 也集成到 Vue 的官方调试工具 <span class="s7">devtools extension</span><span>，提供了诸如零配置的 time-travel 调试、状态快照导入导出等高级调试<br/>功能。</span></p></li></ul></li><li><p class="s4" style="padding-top: 4pt;padding-left: 35pt;text-indent: -18pt;text-align: left;">状态管理<span class="s3">到底是什么？</span></p><ul id="l3"><li><p class="s4" style="padding-top: 3pt;padding-left: 60pt;text-indent: -21pt;text-align: left;">状态管理模式、集中式存储管理<span class="s3">这些名词听起来就非常高大上，让人捉摸不透。</span></p></li><li><p class="s3" style="padding-top: 3pt;padding-left: 60pt;text-indent: -21pt;text-align: left;">其实，你可以简单的将其看成把需要多个组件共享的变量全部存储在一个对象里面。</p></li><li><p class="s3" style="padding-top: 3pt;padding-left: 60pt;text-indent: -21pt;text-align: left;">然后，将这个对象放在顶层的Vue实例中，让其他组件可以使用。</p></li><li><p class="s3" style="padding-top: 3pt;padding-left: 60pt;text-indent: -21pt;text-align: left;">那么，多个组件是不是就可以共享这个对象中的所有变量属性了呢？</p></li></ul></li><li><p class="s3" style="padding-top: 3pt;padding-left: 35pt;text-indent: -18pt;text-align: left;">等等，如果是这样的话，为什么官方还要专门出一个插件Vuex呢？难道我们不能自己封装一个对象来管理吗？</p><ul id="l4"><li><p class="s3" style="padding-top: 3pt;padding-left: 60pt;text-indent: -21pt;text-align: left;">当然可以，只是我们要先想想VueJS带给我们最大的便利是什么呢？没错，就是响应式。</p></li><li><p class="s3" style="padding-top: 3pt;padding-left: 60pt;text-indent: -21pt;text-align: left;">如果你自己封装实现一个对象能不能保证它里面所有的属性做到响应式呢？当然也可以，只是自己封装可能稍微麻烦一些。</p><p style="text-indent: 0pt;text-align: left;"><span><img width="1119" height="6" alt="image" src="index_files/Image_006.png"/></span></p></li><li><p class="s3" style="padding-top: 3pt;padding-left: 60pt;text-indent: -21pt;text-align: left;">不用怀疑，Vuex就是为了提供这样一个在多个组件间共享状态的插件，用它就可以了。</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="text-indent: 0pt;text-align: left;"/><p style="text-indent: 0pt;text-align: left;"><span><img width="1119" height="7" alt="image" src="index_files/Image_007.png"/></span></p><p style="text-indent: 0pt;text-align: left;"><span><img width="141" height="50" alt="image" src="index_files/Image_008.jpg"/></span></p><h2 style="padding-left: 138pt;text-indent: 0pt;line-height: 55pt;text-align: left;">管理什么状态呢?</h2><p style="text-indent: 0pt;text-align: left;"><br/></p></li></ul></li><li><p style="padding-top: 1pt;padding-left: 35pt;text-indent: -18pt;text-align: left;">但是，有什么状态时需要我们在多个组件间共享的呢？</p><ul id="l5"><li><p style="padding-top: 5pt;padding-left: 60pt;text-indent: -21pt;text-align: left;">如果你做过大型开放，你一定遇到过多个状态，在多个界面间的共享问题。</p></li><li><p style="padding-top: 5pt;padding-left: 60pt;text-indent: -21pt;text-align: left;">比如用户的登录状态、用户名称、头像、地理位置信息等等。</p></li><li><p style="padding-top: 5pt;padding-left: 60pt;text-indent: -21pt;text-align: left;">比如商品的收藏、购物车中的物品等等。</p></li><li><p style="padding-top: 5pt;padding-left: 60pt;text-indent: -21pt;text-align: left;"><span>这些状态信息，我们都可以放在统一的地方，对它进行保存和管理，而且它们还是响应式的（待会儿我们就可<br/>以看到代码了，莫着急）。</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="text-indent: 0pt;text-align: left;"><span><img width="162" height="144" alt="image" src="index_files/Image_009.jpg"/></span></p></li></ul></li><li><p style="padding-left: 35pt;text-indent: -18pt;text-align: left;">OK，从理论上理解了状态管理之后，让我们从实际的代码再来看看状态管理。</p><ul id="l6"><li><p style="padding-top: 5pt;padding-left: 60pt;text-indent: -21pt;text-align: left;">毕竟，Talk is cheap, Show me the code.(来自Linus)</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="text-indent: 0pt;text-align: left;"><span><img width="1119" height="6" alt="image" src="index_files/Image_010.png"/></span></p></li></ul></li><li><p style="padding-left: 35pt;text-indent: -18pt;text-align: left;">我们先来看看但界面的状态管理吧.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="text-indent: 0pt;text-align: left;"/><p style="text-indent: 0pt;text-align: left;"><span><img width="1119" height="7" alt="image" src="index_files/Image_011.png"/></span></p><p style="text-indent: 0pt;text-align: left;"><span><img width="141" height="50" alt="image" src="index_files/Image_012.jpg"/></span></p><h2 style="padding-left: 138pt;text-indent: 0pt;line-height: 55pt;text-align: left;">单界面的状态管理</h2><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="text-indent: 0pt;text-align: left;"><span><img width="383" height="259" alt="image" src="index_files/Image_013.png"/></span></p></li><li><p style="padding-top: 1pt;padding-left: 35pt;text-indent: -18pt;text-align: left;">我们知道，要在单个组件中进行状态管理是一件非常简单的事情</p><ul id="l7"><li><p style="padding-top: 3pt;padding-left: 60pt;text-indent: -21pt;text-align: left;">什么意思呢？我们来看下面的图片。</p></li></ul></li><li><p style="padding-top: 3pt;padding-left: 35pt;text-indent: -18pt;text-align: left;">这图片中的三种东西，怎么理解呢？</p><ul id="l8"><li><p style="padding-top: 4pt;padding-left: 60pt;text-indent: -21pt;line-height: 93%;text-align: left;"><span>State：不用多说，就是我们的状态。（你姑且可以当做就是<br/>data中的属性）</span></p></li><li><p style="padding-top: 5pt;padding-left: 60pt;text-indent: -21pt;line-height: 93%;text-align: left;"><span>View：视图层，可以针对State的变化，显示不同的信息。（这<br/>个好理解吧？）</span></p><p style="text-indent: 0pt;text-align: left;"><span><img width="78" height="35" alt="image" src="index_files/Image_014.gif"/></span></p></li><li><p style="padding-top: 5pt;padding-left: 60pt;text-indent: -21pt;line-height: 93%;text-align: left;"><span>Actions：这里的Actions主要是用户的各种操作：点击、输入等<br/>等，会导致状态的改变。</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p></li></ul></li><li><p style="padding-left: 35pt;text-indent: -18pt;text-align: left;">写点代码，加深理解：</p><p style="text-indent: 0pt;text-align: left;"><span><img width="1119" height="6" alt="image" src="index_files/Image_015.png"/></span></p><ul id="l9"><li><p style="padding-top: 3pt;padding-left: 60pt;text-indent: -21pt;text-align: left;">看下右边的代码效果, 肯定会实现吧?</p></li></ul></li></ul><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="text-indent: 0pt;text-align: left;"><span><img width="1119" height="7" alt="image" src="index_files/Image_016.png"/></span></p><p style="text-indent: 0pt;text-align: left;"><span><img width="141" height="50" alt="image" src="index_files/Image_017.jpg"/></span></p><h2 style="padding-left: 138pt;text-indent: 0pt;line-height: 55pt;text-align: left;">单界面状态管理的实现</h2><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="text-indent: 0pt;text-align: left;"><span><img width="479" height="504" alt="image" src="index_files/Image_018.png"/></span></p><ul id="l10"><li><p style="padding-left: 26pt;text-indent: -18pt;text-align: left;"><span>在这个案例中，我们有木有状态需要管理呢？没<br/>错，就是个数counter。</span></p></li><li><p style="padding-top: 4pt;padding-left: 26pt;text-indent: -18pt;text-align: left;"><span>counter需要某种方式被记录下来，也就是我们<br/>的State。</span></p></li><li><p style="padding-top: 5pt;padding-left: 26pt;text-indent: -18pt;text-align: left;"><span>counter目前的值需要被显示在界面中，也就是<br/>我们的View部分。</span></p></li><li><p style="padding-top: 5pt;padding-left: 26pt;text-indent: -18pt;text-align: left;"><span>界面发生某些操作时（我们这里是用户的点击，<br/>也可以是用户的input），需要去更新状态，也就<br/>是我们的Actions</span></p><p style="text-indent: 0pt;text-align: left;"><span><img width="1119" height="6" alt="image" src="index_files/Image_019.png"/></span></p></li><li><p style="padding-top: 5pt;padding-left: 26pt;text-indent: -18pt;text-align: left;">这不就是上面的流程图了吗？</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="text-indent: 0pt;text-align: left;"/><p style="text-indent: 0pt;text-align: left;"><span><img width="1119" height="7" alt="image" src="index_files/Image_020.png"/></span></p><p style="text-indent: 0pt;text-align: left;"><span><img width="141" height="50" alt="image" src="index_files/Image_021.jpg"/></span></p><h2 style="padding-left: 138pt;text-indent: 0pt;line-height: 55pt;text-align: left;">多界面状态管理</h2><p style="text-indent: 0pt;text-align: left;"><br/></p><ul id="l11"><li><p style="padding-top: 1pt;padding-left: 35pt;text-indent: -18pt;text-align: left;">Vue已经帮我们做好了单个界面的状态管理，但是如果是多个界面呢？</p><ul id="l12"><li><p style="padding-top: 3pt;padding-left: 60pt;text-indent: -21pt;text-align: left;">多个试图都依赖同一个状态（一个状态改了，多个界面需要进行更新）</p></li><li><p style="padding-top: 3pt;padding-left: 60pt;text-indent: -21pt;text-align: left;">不同界面的Actions都想修改同一个状态（Home.vue需要修改，Profile.vue也需要修改这个状态）</p></li></ul></li><li><p style="padding-top: 4pt;padding-left: 35pt;text-indent: -18pt;line-height: 93%;text-align: left;"><span>也就是说对于某些状态(状态1/状态2/状态3)来说只属于我们某一个试图，但是也有一些状态(状态a/状态b/状态c)<br/>属于多个试图共同想要维护的</span></p><ul id="l13"><li><p style="padding-top: 3pt;padding-left: 60pt;text-indent: -21pt;text-align: left;">状态1/状态2/状态3你放在自己的房间中，你自己管理自己用，没问题。</p></li><li><p style="padding-top: 3pt;padding-left: 60pt;text-indent: -21pt;text-align: left;">但是状态a/状态b/状态c我们希望交给一个大管家来统一帮助我们管理！！！</p></li><li><p style="padding-top: 3pt;padding-left: 60pt;text-indent: -21pt;text-align: left;">没错，Vuex就是为我们提供这个大管家的工具。</p></li></ul></li><li><p style="padding-top: 3pt;padding-left: 35pt;text-indent: -18pt;text-align: left;">全局单例模式（大管家）</p><ul id="l14"><li><p style="padding-top: 3pt;padding-left: 60pt;text-indent: -21pt;text-align: left;">我们现在要做的就是将共享的状态抽取出来，交给我们的大管家，统一进行管理。</p></li><li><p style="padding-top: 3pt;padding-left: 60pt;text-indent: -21pt;text-align: left;">之后，你们每个试图，按照我<b>规定好的</b>规定，进行访问和修改等操作。</p><p style="text-indent: 0pt;text-align: left;"><span><img width="1119" height="6" alt="image" src="index_files/Image_022.png"/></span></p></li><li><p style="padding-top: 3pt;padding-left: 60pt;text-indent: -21pt;text-align: left;">这就是Vuex背后的基本思想。</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="text-indent: 0pt;text-align: left;"/><p style="text-indent: 0pt;text-align: left;"><span><img width="1119" height="7" alt="image" src="index_files/Image_023.png"/></span></p><p style="text-indent: 0pt;text-align: left;"><span><img width="141" height="50" alt="image" src="index_files/Image_024.jpg"/></span></p><h2 style="padding-left: 138pt;text-indent: 0pt;line-height: 55pt;text-align: left;">Vuex状态管理图例</h2><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="text-indent: 0pt;text-align: left;"><span><img width="1119" height="6" alt="image" src="index_files/Image_025.png"/></span></p></li></ul></li><li><p style="padding-top: 1pt;padding-left: 35pt;text-indent: -18pt;text-align: left;">一起在来看一副官方给出的图片</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 32pt;text-indent: 0pt;text-align: left;"><span><img width="547" height="44" alt="image" src="index_files/Image_026.png"/></span><span><img width="547" height="5" alt="image" src="index_files/Image_027.png"/></span><span><img width="547" height="5" alt="image" src="index_files/Image_028.png"/></span><span><img width="547" height="14" alt="image" src="index_files/Image_029.png"/></span><span><img width="547" height="5" alt="image" src="index_files/Image_030.png"/></span><span><img width="547" height="5" alt="image" src="index_files/Image_031.png"/></span><span><img width="547" height="264" alt="image" src="index_files/Image_032.png"/></span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="text-indent: 0pt;text-align: left;"/><p style="text-indent: 0pt;text-align: left;"><span><img width="1119" height="7" alt="image" src="index_files/Image_033.png"/></span></p><p style="text-indent: 0pt;text-align: left;"><span><img width="141" height="50" alt="image" src="index_files/Image_034.jpg"/></span></p><h2 style="padding-left: 138pt;text-indent: 0pt;line-height: 55pt;text-align: left;">简单的案例</h2><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="text-indent: 0pt;text-align: left;"><span><img width="455" height="462" alt="image" src="index_files/Image_035.png"/></span></p></li><li><p style="padding-top: 1pt;padding-left: 35pt;text-indent: -18pt;text-align: left;">我们还是实现一下之前简单的案例</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 42pt;text-indent: 0pt;text-align: left;"><span><img width="56" height="48" alt="image" src="index_files/Image_036.gif"/></span></p><p style="text-indent: 0pt;text-align: left;"><br/></p></li><li><p style="padding-left: 35pt;text-indent: -18pt;text-align: left;">首先，我们需要在某个地方存放我们的Vuex代码：</p><ul id="l15"><li><p style="padding-top: 5pt;padding-left: 60pt;text-indent: -21pt;text-align: left;"><span>这里，我们先创建一个文件夹store，并且在其中创建一<br/>个index.js文件</span></p><p style="text-indent: 0pt;text-align: left;"><span><img width="1119" height="6" alt="image" src="index_files/Image_037.png"/></span></p></li><li><p style="padding-top: 5pt;padding-left: 60pt;text-indent: -21pt;text-align: left;">在index.js文件中写入如下代码：</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="text-indent: 0pt;text-align: left;"/><p style="text-indent: 0pt;text-align: left;"><span><img width="1119" height="7" alt="image" src="index_files/Image_038.png"/></span></p><p style="text-indent: 0pt;text-align: left;"><span><img width="141" height="50" alt="image" src="index_files/Image_039.jpg"/></span></p><h2 style="padding-left: 138pt;text-indent: 0pt;line-height: 55pt;text-align: left;">挂载到Vue实例中</h2><p style="text-indent: 0pt;text-align: left;"><br/></p></li></ul></li><li><p style="padding-top: 1pt;padding-left: 35pt;text-indent: -18pt;text-align: left;">其次，我们让所有的Vue组件都可以使用这个store对象</p><ul id="l16"><li><p style="padding-top: 5pt;padding-left: 60pt;text-indent: -21pt;text-align: left;">来到main.js文件，导入store对象，并且放在new Vue中</p><p style="text-indent: 0pt;text-align: left;"><span><img width="1119" height="6" alt="image" src="index_files/Image_040.png"/></span></p></li><li><p style="padding-top: 5pt;padding-left: 60pt;text-indent: -21pt;text-align: left;">这样，在其他Vue组件中，我们就可以通过this.$store的方式，获取到这个store对象了</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 49pt;text-indent: 0pt;text-align: left;"><span><img width="537" height="269" alt="image" src="index_files/Image_041.jpg"/></span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="text-indent: 0pt;text-align: left;"><span><img width="1119" height="7" alt="image" src="index_files/Image_042.png"/></span></p><p class="s8" style="padding-left: 13pt;text-indent: 0pt;line-height: 55pt;text-align: left;"><span><img width="141" height="50" alt="image" src="index_files/Image_043.jpg"/></span>        <span class="h2">使用Vuex的count</span></p><p style="text-indent: 0pt;text-align: left;"><span><img width="1119" height="6" alt="image" src="index_files/Image_044.png"/></span><span><img width="388" height="494" alt="image" src="index_files/Image_045.png"/></span></p><ul id="l17"><li><p class="s9" style="padding-top: 14pt;padding-left: 397pt;text-indent: -18pt;text-align: left;">好的，这就是使用Vuex最简单的方式了。</p></li><li><p class="s9" style="padding-top: 1pt;padding-left: 397pt;text-indent: -18pt;text-align: left;">我们来对使用步骤，做一个简单的小节：</p><ul id="l18"><li><p class="s9" style="padding-top: 4pt;padding-left: 422pt;text-indent: -21pt;line-height: 87%;text-align: left;"><span>1.提取出一个公共的store对象，用于保存在多个组件中共享<br/>的状态</span></p></li><li><p class="s9" style="padding-top: 5pt;padding-left: 422pt;text-indent: -21pt;line-height: 87%;text-align: left;"><span>2.将store对象放置在new Vue对象中，这样可以保证在所有<br/>的组件中都可以使用到</span></p></li><li><p class="s9" style="padding-top: 2pt;padding-left: 422pt;text-indent: -21pt;text-align: left;">3.在其他组件中使用store对象中保存的状态即可</p><ul id="l19"><li><p class="s3" style="padding-top: 1pt;padding-left: 440pt;text-indent: -15pt;text-align: left;">通过this.$store.state.属性的方式来访问状态</p></li><li><p class="s3" style="padding-top: 1pt;padding-left: 440pt;text-indent: -15pt;text-align: left;">通过this.$store.commit(&#39;mutation中方法&#39;)来修改状态</p></li></ul></li></ul></li><li><p class="s9" style="padding-top: 2pt;padding-left: 397pt;text-indent: -18pt;text-align: left;">注意事项：</p><ul id="l20"><li><p class="s9" style="padding-top: 4pt;padding-left: 422pt;text-indent: -21pt;line-height: 87%;text-align: left;"><span>我们通过提交mutation的方式，而非直接改变<br/>store.state.count。</span></p></li><li><p class="s9" style="padding-top: 5pt;padding-left: 422pt;text-indent: -21pt;line-height: 87%;text-align: left;"><span>这是因为Vuex可以更明确的追踪状态的变化，所以不要直接<br/>改变store.state.count的值。</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="text-indent: 0pt;text-align: left;"/><p style="text-indent: 0pt;text-align: left;"><span><img width="1119" height="7" alt="image" src="index_files/Image_046.png"/></span></p><p style="text-indent: 0pt;text-align: left;"><span><img width="141" height="50" alt="image" src="index_files/Image_047.jpg"/></span></p><h2 style="padding-left: 138pt;text-indent: 0pt;line-height: 55pt;text-align: left;">Vuex核心概念</h2><p style="text-indent: 0pt;text-align: left;"><br/></p></li></ul></li></ul></li></ul></li><li><p style="padding-top: 1pt;padding-left: 35pt;text-indent: -18pt;text-align: left;">Vuex有几个比较核心的概念:</p><ul id="l21"><li><p style="padding-top: 5pt;padding-left: 60pt;text-indent: -21pt;text-align: left;">State</p></li><li><p style="padding-top: 5pt;padding-left: 60pt;text-indent: -21pt;text-align: left;">Getters</p></li><li><p style="padding-top: 5pt;padding-left: 60pt;text-indent: -21pt;text-align: left;">Mutation</p></li><li><p style="padding-top: 5pt;padding-left: 60pt;text-indent: -21pt;text-align: left;">Action</p></li><li><p style="padding-top: 5pt;padding-left: 60pt;text-indent: -21pt;text-align: left;">Module</p><p style="text-indent: 0pt;text-align: left;"><span><img width="1119" height="6" alt="image" src="index_files/Image_048.png"/></span></p></li></ul></li><li><p style="padding-top: 5pt;padding-left: 35pt;text-indent: -18pt;text-align: left;">我们对它进行一一介绍.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="text-indent: 0pt;text-align: left;"/><p style="text-indent: 0pt;text-align: left;"><span><img width="1119" height="7" alt="image" src="index_files/Image_049.png"/></span></p><p style="text-indent: 0pt;text-align: left;"><span><img width="141" height="50" alt="image" src="index_files/Image_050.jpg"/></span></p><h2 style="padding-left: 138pt;text-indent: 0pt;line-height: 55pt;text-align: left;">State单一状态树</h2><p style="text-indent: 0pt;text-align: left;"><br/></p></li><li><p class="s3" style="padding-top: 1pt;padding-left: 35pt;text-indent: -18pt;text-align: left;">Vuex提出使用单一状态树, 什么是单一状态树呢？</p><ul id="l22"><li><p class="s3" style="padding-top: 3pt;padding-left: 60pt;text-indent: -21pt;text-align: left;">英文名称是Single Source of Truth，也可以翻译成单一数据源。</p></li></ul></li><li><p class="s3" style="padding-top: 3pt;padding-left: 35pt;text-indent: -18pt;text-align: left;">但是，它是什么呢？我们来看一个生活中的例子。</p><ul id="l23"><li><p class="s3" style="padding-top: 3pt;padding-left: 60pt;text-indent: -21pt;text-align: left;">OK，我用一个生活中的例子做一个简单的类比。</p></li><li><p class="s3" style="padding-top: 4pt;padding-left: 60pt;text-indent: -21pt;line-height: 92%;text-align: left;"><span>我们知道，在国内我们有很多的信息需要被记录，比如上学时的个人档案，工作后的社保记录，公积金记录，结婚后的婚姻信息，以<br/>及其他相关的户口、医疗、文凭、房产记录等等（还有很多信息）。</span></p></li><li><p class="s3" style="padding-top: 5pt;padding-left: 60pt;text-indent: -21pt;line-height: 92%;text-align: left;"><span>这些信息被分散在很多地方进行管理，有一天你需要办某个业务时(比如入户某个城市)，你会发现你需要到各个对应的工作地点去打<br/>印、盖章各种资料信息，最后到一个地方提交证明你的信息无误。</span></p></li><li><p class="s3" style="padding-top: 5pt;padding-left: 60pt;text-indent: -21pt;line-height: 92%;text-align: left;"><span>这种保存信息的方案，不仅仅低效，而且不方便管理，以及日后的维护也是一个庞大的工作(需要大量的各个部门的人力来维护，当<br/>然国家目前已经在完善我们的这个系统了)。</span></p></li></ul></li><li><p class="s3" style="padding-top: 4pt;padding-left: 35pt;text-indent: -18pt;text-align: left;">这个和我们在应用开发中比较类似：</p><ul id="l24"><li><p class="s3" style="padding-top: 3pt;padding-left: 60pt;text-indent: -21pt;text-align: left;">如果你的状态信息是保存到多个Store对象中的，那么之后的管理和维护等等都会变得特别困难。</p></li><li><p class="s3" style="padding-top: 3pt;padding-left: 60pt;text-indent: -21pt;text-align: left;">所以Vuex也使用了单一状态树来管理应用层级的全部状态。</p><p style="text-indent: 0pt;text-align: left;"><span><img width="1119" height="6" alt="image" src="index_files/Image_051.png"/></span></p></li><li><p class="s3" style="padding-top: 3pt;padding-left: 60pt;text-indent: -21pt;text-align: left;">单一状态树能够让我们最直接的方式找到某个状态的片段，而且在之后的维护和调试过程中，也可以非常方便的管理和维护。</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="text-indent: 0pt;text-align: left;"/><p style="text-indent: 0pt;text-align: left;"><span><img width="1119" height="7" alt="image" src="index_files/Image_052.png"/></span></p><p style="text-indent: 0pt;text-align: left;"><span><img width="141" height="50" alt="image" src="index_files/Image_053.jpg"/></span></p><h2 style="padding-left: 138pt;text-indent: 0pt;line-height: 55pt;text-align: left;">Getters基本使用</h2><p style="text-indent: 0pt;text-align: left;"><br/></p></li></ul></li><li><p style="padding-top: 1pt;padding-left: 35pt;text-indent: -18pt;text-align: left;">有时候，我们需要从store中获取一些state变异后的状态，比如下面的Store中：</p><ul id="l25"><li><p style="padding-top: 5pt;padding-left: 60pt;text-indent: -21pt;text-align: left;">获取学生年龄大于20的个数。</p><p style="padding-left: 44pt;text-indent: 0pt;text-align: left;"><span><img width="478" height="215" alt="image" src="index_files/Image_054.jpg"/></span></p><p style="text-indent: 0pt;text-align: left;"><span><img width="1119" height="6" alt="image" src="index_files/Image_055.png"/></span></p></li></ul></li><li><p style="padding-top: 12pt;padding-left: 35pt;text-indent: -18pt;text-align: left;">我们可以在Store中定义getters</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s8" style="padding-left: 33pt;text-indent: 0pt;text-align: left;"><span><img width="581" height="108" alt="image" src="index_files/Image_056.jpg"/></span> <span><img width="465" height="101" alt="image" src="index_files/Image_057.jpg"/></span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="text-indent: 0pt;text-align: left;"/><p style="text-indent: 0pt;text-align: left;"><span><img width="1119" height="7" alt="image" src="index_files/Image_058.png"/></span></p><p style="text-indent: 0pt;text-align: left;"><span><img width="141" height="50" alt="image" src="index_files/Image_059.jpg"/></span></p><h2 style="padding-left: 138pt;text-indent: 0pt;line-height: 55pt;text-align: left;">Getters作为参数和传递参数</h2><p style="text-indent: 0pt;text-align: left;"><br/></p></li><li><p style="padding-top: 1pt;padding-bottom: 1pt;padding-left: 35pt;text-indent: -18pt;text-align: left;">如果我们已经有了一个获取所有年龄大于20岁学生列表的getters, 那么代码可以这样来写</p><p style="padding-left: 38pt;text-indent: 0pt;text-align: left;"><span><img width="493" height="181" alt="image" src="index_files/Image_060.jpg"/></span></p></li><li><p style="padding-top: 2pt;padding-left: 35pt;text-indent: -18pt;text-align: left;">getters默认是不能传递参数的, 如果希望传递参数, 那么只能让getters本身返回另一个函数.</p><p style="text-indent: 0pt;text-align: left;"><span><img width="1119" height="6" alt="image" src="index_files/Image_061.png"/></span></p><ul id="l26"><li><p style="padding-top: 5pt;padding-left: 60pt;text-indent: -21pt;text-align: left;">比如上面的案例中,我们希望根据ID获取用户的信息</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 30pt;text-indent: 0pt;text-align: left;"><span><img width="459" height="146" alt="image" src="index_files/Image_062.gif"/></span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="text-indent: 0pt;text-align: left;"/><p style="text-indent: 0pt;text-align: left;"><span><img width="1119" height="7" alt="image" src="index_files/Image_063.png"/></span></p><p style="text-indent: 0pt;text-align: left;"><span><img width="141" height="50" alt="image" src="index_files/Image_064.jpg"/></span></p><h2 style="padding-left: 138pt;text-indent: 0pt;line-height: 55pt;text-align: left;">Mutation状态更新</h2><p style="text-indent: 0pt;text-align: left;"><br/></p></li></ul></li><li><p style="padding-top: 1pt;padding-left: 35pt;text-indent: -18pt;text-align: left;">Vuex的store状态的更新唯一方式：<u><b>提交Mutation</b></u></p></li><li><p style="padding-top: 5pt;padding-left: 35pt;text-indent: -18pt;text-align: left;">Mutation主要包括两部分：</p><ul id="l27"><li><p style="padding-top: 5pt;padding-left: 60pt;text-indent: -21pt;text-align: left;">字符串的<b>事件类型（type）</b></p></li><li><p style="padding-top: 5pt;padding-left: 60pt;text-indent: -21pt;text-align: left;">一个<b>回调函数（handler）</b>,该回调函数的第一个参数就是state。</p></li></ul></li><li><p style="padding-top: 5pt;padding-left: 35pt;text-indent: -18pt;text-align: left;">mutation的定义方式：</p><p style="padding-left: 36pt;text-indent: 0pt;text-align: left;"><span><img width="292" height="96" alt="image" src="index_files/Image_065.gif"/></span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="text-indent: 0pt;text-align: left;"><span><img width="1119" height="6" alt="image" src="index_files/Image_066.png"/></span></p></li><li><p style="padding-bottom: 4pt;padding-left: 35pt;text-indent: -18pt;text-align: left;">通过mutation更新</p><p style="padding-left: 34pt;text-indent: 0pt;text-align: left;"><span><img width="299" height="69" alt="image" src="index_files/Image_067.gif"/></span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="text-indent: 0pt;text-align: left;"/><p style="text-indent: 0pt;text-align: left;"><span><img width="1119" height="7" alt="image" src="index_files/Image_068.png"/></span></p><p style="text-indent: 0pt;text-align: left;"><span><img width="141" height="50" alt="image" src="index_files/Image_069.jpg"/></span></p><h2 style="padding-left: 138pt;text-indent: 0pt;line-height: 55pt;text-align: left;">Mutation传递参数</h2><p style="text-indent: 0pt;text-align: left;"><br/></p></li><li><p style="padding-top: 1pt;padding-left: 35pt;text-indent: -18pt;text-align: left;">在通过mutation更新数据的时候, 有可能我们希望携带一些<b>额外的参数</b></p><ul id="l28"><li><p style="padding-top: 5pt;padding-left: 60pt;text-indent: -21pt;text-align: left;">参数被称为是mutation的载荷(Payload)</p></li></ul></li><li><p style="padding-top: 5pt;padding-left: 35pt;text-indent: -18pt;text-align: left;">Mutation中的代码:</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s11" style="padding-left: 35pt;text-indent: 0pt;text-align: left;"><span><img width="235" height="70" alt="image" src="index_files/Image_070.gif"/></span>	<span><img width="324" height="69" alt="image" src="index_files/Image_071.gif"/></span></p></li><li><p style="padding-top: 12pt;padding-left: 35pt;text-indent: -18pt;text-align: left;">但是如果参数不是一个呢?</p><ul id="l29"><li><p style="padding-top: 5pt;padding-left: 60pt;text-indent: -21pt;text-align: left;">比如我们有很多参数需要传递.</p></li><li><p style="padding-top: 5pt;padding-left: 60pt;text-indent: -21pt;text-align: left;">这个时候, 我们通常会以对象的形式传递, 也就是payload是一个对象.</p><p style="text-indent: 0pt;text-align: left;"><span><img width="1119" height="6" alt="image" src="index_files/Image_072.png"/></span></p></li><li><p style="padding-top: 5pt;padding-bottom: 3pt;padding-left: 60pt;text-indent: -21pt;text-align: left;">这个时候可以再从对象中取出相关的信息.</p><p class="s11" style="padding-left: 32pt;text-indent: 0pt;text-align: left;"><span><img width="290" height="70" alt="image" src="index_files/Image_073.gif"/></span>	<span><img width="399" height="70" alt="image" src="index_files/Image_074.gif"/></span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="text-indent: 0pt;text-align: left;"/><p style="text-indent: 0pt;text-align: left;"><span><img width="1119" height="7" alt="image" src="index_files/Image_075.png"/></span></p><p style="text-indent: 0pt;text-align: left;"><span><img width="141" height="50" alt="image" src="index_files/Image_076.jpg"/></span></p><h2 style="padding-left: 138pt;text-indent: 0pt;line-height: 55pt;text-align: left;">Mutation提交风格</h2><p style="text-indent: 0pt;text-align: left;"><br/></p></li></ul></li><li><p style="padding-top: 1pt;padding-left: 35pt;text-indent: -18pt;text-align: left;">上面的通过<b>commit</b>进行提交是一种普通的方式</p></li><li><p style="padding-top: 5pt;padding-left: 35pt;text-indent: -18pt;text-align: left;">Vue还提供了另外一种风格, 它是一个包含type属性的对象</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 35pt;text-indent: 0pt;text-align: left;"><span><img width="300" height="90" alt="image" src="index_files/Image_077.gif"/></span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="text-indent: 0pt;text-align: left;"><span><img width="1119" height="6" alt="image" src="index_files/Image_078.png"/></span></p></li><li><p style="padding-left: 35pt;text-indent: -18pt;text-align: left;">Mutation中的处理方式是将整个commit的对象作为payload使用, 所以代码没有改变, 依然如下:</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 35pt;text-indent: 0pt;text-align: left;"><span><img width="298" height="69" alt="image" src="index_files/Image_079.gif"/></span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="text-indent: 0pt;text-align: left;"/><p style="text-indent: 0pt;text-align: left;"><span><img width="1119" height="7" alt="image" src="index_files/Image_080.png"/></span></p><p style="text-indent: 0pt;text-align: left;"><span><img width="141" height="50" alt="image" src="index_files/Image_081.jpg"/></span></p><h2 style="padding-left: 138pt;text-indent: 0pt;line-height: 55pt;text-align: left;">Mutation响应规则</h2><p style="text-indent: 0pt;text-align: left;"><br/></p></li><li><p style="padding-top: 1pt;padding-left: 35pt;text-indent: -18pt;text-align: left;">Vuex的store中的state是响应式的, 当state中的数据发生改变时, Vue组件会自动更新.</p><p style="text-indent: 0pt;text-align: left;"><span><img width="521" height="250" alt="image" src="index_files/Image_082.png"/></span></p></li><li><p style="padding-top: 5pt;padding-left: 35pt;text-indent: -18pt;text-align: left;">这就要求我们必须遵守一些Vuex对应的规则:</p><ul id="l30"><li><p style="padding-top: 5pt;padding-left: 60pt;text-indent: -21pt;text-align: left;">提前在store中初始化好所需的属性.</p></li><li><p style="padding-top: 5pt;padding-left: 60pt;text-indent: -21pt;text-align: left;">当给state中的对象添加新属性时, 使用下面的方式:</p><ul id="l31"><li><p class="s12" style="padding-top: 4pt;padding-left: 79pt;text-indent: -15pt;text-align: left;">方式一: 使用Vue.set(obj, &#39;newProp&#39;, 123)</p></li><li><p class="s12" style="padding-top: 4pt;padding-left: 79pt;text-indent: -15pt;text-align: left;">方式二: 用心对象给旧对象重新赋值</p></li></ul></li></ul></li><li><p style="padding-top: 5pt;padding-left: 35pt;text-indent: -18pt;text-align: left;">我们来看一个例子:</p><p style="text-indent: 0pt;text-align: left;"><span><img width="534" height="178" alt="image" src="index_files/Image_083.jpg"/></span></p><ul id="l32"><li><p style="padding-top: 5pt;padding-left: 60pt;text-indent: -21pt;text-align: left;">当我们点击更新信息时, 界面并没有发生对应改变.</p></li></ul></li><li><p style="padding-top: 5pt;padding-left: 35pt;text-indent: -18pt;text-align: left;">如何才能让它改变呢?</p><ul id="l33"><li><p style="padding-top: 5pt;padding-left: 60pt;text-indent: -21pt;text-align: left;">查看下面代码的方式一和方式二</p><p style="text-indent: 0pt;text-align: left;"><span><img width="1119" height="6" alt="image" src="index_files/Image_084.png"/></span></p></li><li><p style="padding-top: 5pt;padding-left: 60pt;text-indent: -21pt;text-align: left;">都可以让state中的属性是响应式的.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="text-indent: 0pt;text-align: left;"/><p style="text-indent: 0pt;text-align: left;"><span><img width="1119" height="7" alt="image" src="index_files/Image_085.png"/></span></p><p style="text-indent: 0pt;text-align: left;"><span><img width="141" height="50" alt="image" src="index_files/Image_086.jpg"/></span></p><h2 style="padding-left: 138pt;text-indent: 0pt;line-height: 55pt;text-align: left;">Mutation常量类型 – 概念</h2><p style="text-indent: 0pt;text-align: left;"><br/></p></li></ul></li><li><p style="padding-top: 1pt;padding-left: 35pt;text-indent: -18pt;text-align: left;">我们来考虑下面的问题:</p><ul id="l34"><li><p style="padding-top: 3pt;padding-left: 60pt;text-indent: -21pt;text-align: left;">在mutation中, 我们定义了很多事件类型(也就是其中的方法名称).</p></li><li><p style="padding-top: 4pt;padding-left: 60pt;text-indent: -21pt;line-height: 92%;text-align: left;"><span>当我们的项目增大时, Vuex管理的状态越来越多, 需要更新状态的情况越来越多, 那么意味着Mutation中的方法<br/>越来越多.</span></p></li><li><p style="padding-top: 5pt;padding-left: 60pt;text-indent: -21pt;line-height: 92%;text-align: left;"><span>方法过多, 使用者需要花费大量的经历去记住这些方法, 甚至是多个文件间来回切换, 查看方法名称, 甚至如果不<br/>是复制的时候, 可能还会出现写错的情况.</span></p></li></ul></li><li><p style="padding-top: 4pt;padding-left: 35pt;text-indent: -18pt;text-align: left;">如何避免上述的问题呢?</p><ul id="l35"><li><p style="padding-top: 3pt;padding-left: 60pt;text-indent: -21pt;text-align: left;">在各种Flux实现中, 一种很常见的方案就是使用<b>常量</b>替代Mutation<b>事件的类型.</b></p></li><li><p style="padding-top: 3pt;padding-left: 60pt;text-indent: -21pt;text-align: left;">我们可以将这些常量放在一个单独的文件中, 方便管理以及让整个app所有的事件类型一目了然.</p></li></ul></li><li><p style="padding-top: 3pt;padding-left: 35pt;text-indent: -18pt;text-align: left;">具体怎么做呢?</p><ul id="l36"><li><p style="padding-top: 3pt;padding-left: 60pt;text-indent: -21pt;text-align: left;">我们可以创建一个文件: mutation-types.js, 并且在其中定义我们的常量.</p><p style="text-indent: 0pt;text-align: left;"><span><img width="1119" height="6" alt="image" src="index_files/Image_087.png"/></span></p></li><li><p style="padding-top: 3pt;padding-left: 60pt;text-indent: -21pt;text-align: left;">定义常量时, 我们可以使用ES2015中的风格, 使用一个常量来作为函数的名称.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="text-indent: 0pt;text-align: left;"><span><img width="505" height="69" alt="image" src="index_files/Image_088.jpg"/></span></p><p style="text-indent: 0pt;text-align: left;"><span><img width="1119" height="7" alt="image" src="index_files/Image_089.png"/></span></p><p style="text-indent: 0pt;text-align: left;"><span><img width="1119" height="6" alt="image" src="index_files/Image_090.png"/></span></p><p style="text-indent: 0pt;text-align: left;"><span><img width="141" height="50" alt="image" src="index_files/Image_091.jpg"/></span></p><h2 style="padding-left: 138pt;text-indent: 0pt;line-height: 55pt;text-align: left;">Mutation常量类型 – 代码</h2><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s13" style="padding-left: 7pt;text-indent: 0pt;text-align: left;"><span><img width="533" height="372" alt="image" src="index_files/Image_092.png"/></span>	<span><img width="539" height="384" alt="image" src="index_files/Image_093.png"/></span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="text-indent: 0pt;text-align: left;"/><p style="text-indent: 0pt;text-align: left;"><span><img width="1119" height="7" alt="image" src="index_files/Image_094.png"/></span></p><p style="text-indent: 0pt;text-align: left;"><span><img width="141" height="50" alt="image" src="index_files/Image_095.jpg"/></span></p><h2 style="padding-left: 138pt;text-indent: 0pt;line-height: 55pt;text-align: left;">Mutation同步函数</h2><p style="text-indent: 0pt;text-align: left;"><br/></p></li></ul></li><li><p class="s12" style="padding-top: 1pt;padding-left: 35pt;text-indent: -18pt;text-align: left;">通常情况下, Vuex要求我们Mutation中的方法必须是同步方法.</p><ul id="l37"><li><p class="s12" style="padding-top: 4pt;padding-left: 60pt;text-indent: -21pt;text-align: left;">主要的原因是当我们使用devtools时, 可以devtools可以帮助我们捕捉mutation的快照.</p></li><li><p class="s12" style="padding-top: 4pt;padding-left: 60pt;text-indent: -21pt;text-align: left;">但是如果是异步操作, 那么devtools将不能很好的追踪这个操作什么时候会被完成.</p></li></ul></li><li><p class="s12" style="padding-top: 4pt;padding-left: 35pt;text-indent: -18pt;text-align: left;">比如我们之前的代码, 当执行更新时, devtools中会有如下信息: 图1</p><p style="text-indent: 0pt;text-align: left;"><span><img width="460" height="281" alt="image" src="index_files/Image_096.png"/></span></p></li><li><p class="s12" style="padding-top: 4pt;padding-left: 35pt;text-indent: -18pt;text-align: left;">但是, 如果Vuex中的代码, 我们使用了异步函数: 图2</p><p style="padding-left: 35pt;text-indent: 0pt;text-align: left;"><span><img width="416" height="199" alt="image" src="index_files/Image_097.png"/></span></p></li><li><p class="s12" style="padding-top: 7pt;padding-left: 35pt;text-indent: -18pt;text-align: left;">你会发现state中的info数据一直没有被改变, 因为他无法追踪到.</p><p style="text-indent: 0pt;text-align: left;"><span><img width="1119" height="6" alt="image" src="index_files/Image_098.png"/></span></p></li><li><h4 style="padding-top: 4pt;padding-left: 35pt;text-indent: -18pt;text-align: left;">So, 通常情况下, 不要再mutation中进行异步的操作</h4><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="text-indent: 0pt;text-align: left;"/><p style="text-indent: 0pt;text-align: left;"><span><img width="1119" height="7" alt="image" src="index_files/Image_099.png"/></span></p><p style="text-indent: 0pt;text-align: left;"><span><img width="141" height="50" alt="image" src="index_files/Image_100.jpg"/></span></p><h2 style="padding-left: 138pt;text-indent: 0pt;line-height: 55pt;text-align: left;">Action的基本定义</h2><p style="text-indent: 0pt;text-align: left;"><br/></p></li><li><p class="s3" style="padding-top: 1pt;padding-left: 35pt;text-indent: -18pt;text-align: left;">我们强调, 不要再Mutation中进行异步操作.</p><ul id="l38"><li><p class="s3" style="padding-top: 4pt;padding-left: 60pt;text-indent: -21pt;line-height: 86%;text-align: left;"><span>但是某些情况, 我们确实希望在Vuex中进行一些异步操作, 比如网络请求, 必<br/>然是异步的. 这个时候怎么处理呢?</span></p></li><li><p class="s3" style="padding-top: 2pt;padding-left: 60pt;text-indent: -21pt;text-align: left;">Action类似于Mutation, 但是是用来代替Mutation进行异步操作的.</p></li></ul></li><li><p class="s3" style="padding-top: 1pt;padding-left: 35pt;text-indent: -18pt;text-align: left;">Action的基本使用代码如下:</p><p style="text-indent: 0pt;text-align: left;"><span><img width="1119" height="6" alt="image" src="index_files/Image_101.png"/></span><span><img width="421" height="333" alt="image" src="index_files/Image_102.png"/></span></p></li><li><p class="s3" style="padding-top: 1pt;padding-left: 35pt;text-indent: -18pt;text-align: left;">context是什么?</p><ul id="l39"><li><p class="s3" style="padding-top: 1pt;padding-left: 60pt;text-indent: -21pt;text-align: left;">context是和store对象具有相同方法和属性的对象.</p></li><li><p class="s3" style="padding-top: 4pt;padding-left: 60pt;text-indent: -21pt;line-height: 86%;text-align: left;"><span>也就是说, 我们可以通过context去进行commit相关的操作, 也可以获取<br/>context.state等.</span></p></li><li><p class="s3" style="padding-top: 5pt;padding-left: 60pt;text-indent: -21pt;line-height: 86%;text-align: left;"><span>但是注意, 这里它们并不是同一个对象, 为什么呢? 我们后面学习Modules的<br/>时候, 再具体说.</span></p></li></ul></li><li><p class="s3" style="padding-top: 2pt;padding-left: 35pt;text-indent: -18pt;text-align: left;">这样的代码是否多此一举呢?</p><ul id="l40"><li><p class="s3" style="padding-top: 1pt;padding-left: 60pt;text-indent: -21pt;text-align: left;">我们定义了actions, 然后又在actions中去进行commit, 这不是脱裤放屁吗?</p></li><li><p class="s3" style="padding-top: 4pt;padding-left: 60pt;text-indent: -21pt;line-height: 86%;text-align: left;"><span>事实上并不是这样, 如果在Vuex中有异步操作, 那么我们就可以在actions中完<br/>成了.</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="text-indent: 0pt;text-align: left;"/><p style="text-indent: 0pt;text-align: left;"><span><img width="1119" height="7" alt="image" src="index_files/Image_103.png"/></span></p><p style="text-indent: 0pt;text-align: left;"><span><img width="141" height="50" alt="image" src="index_files/Image_104.jpg"/></span></p><h2 style="padding-left: 138pt;text-indent: 0pt;line-height: 55pt;text-align: left;">Action的分发</h2><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="text-indent: 0pt;text-align: left;"><span><img width="460" height="329" alt="image" src="index_files/Image_105.png"/></span></p></li></ul></li><li><p style="padding-top: 1pt;padding-left: 35pt;text-indent: -18pt;text-align: left;">在Vue组件中, 如果我们调用action中的方法, 那么就需要使用dispatch</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 31pt;text-indent: 0pt;text-align: left;"><span><img width="542" height="140" alt="image" src="index_files/Image_106.jpg"/></span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="text-indent: 0pt;text-align: left;"><span><img width="1119" height="6" alt="image" src="index_files/Image_107.png"/></span></p></li><li><p style="padding-left: 35pt;text-indent: -18pt;text-align: left;">同样的, 也是支持传递payload</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="text-indent: 0pt;text-align: left;"/><p style="text-indent: 0pt;text-align: left;"><span><img width="1119" height="7" alt="image" src="index_files/Image_108.png"/></span></p><p style="text-indent: 0pt;text-align: left;"><span><img width="141" height="50" alt="image" src="index_files/Image_109.jpg"/></span></p><h2 style="padding-left: 138pt;text-indent: 0pt;line-height: 55pt;text-align: left;">Action返回的Promise</h2><p style="text-indent: 0pt;text-align: left;"><br/></p></li><li><p style="padding-top: 1pt;padding-left: 35pt;text-indent: -18pt;text-align: left;">前面我们学习ES6语法的时候说过, Promise经常用于异步操作.</p><ul id="l41"><li><p style="padding-top: 5pt;padding-left: 60pt;text-indent: -21pt;text-align: left;">在Action中, 我们可以将异步操作放在一个Promise中, 并且在成功或者失败后, 调用对应的resolve或reject.</p><p style="text-indent: 0pt;text-align: left;"><span><img width="1119" height="6" alt="image" src="index_files/Image_110.png"/></span><span><img width="535" height="155" alt="image" src="index_files/Image_111.jpg"/></span></p><p style="text-indent: 0pt;text-align: left;"><span><img width="539" height="222" alt="image" src="index_files/Image_112.jpg"/></span></p></li></ul></li><li><p style="padding-top: 5pt;padding-left: 35pt;text-indent: -18pt;text-align: left;">OK, 我们来看下面的代码:</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="text-indent: 0pt;text-align: left;"><span><img width="1119" height="7" alt="image" src="index_files/Image_113.png"/></span></p><p style="text-indent: 0pt;text-align: left;"><span><img width="141" height="50" alt="image" src="index_files/Image_114.jpg"/></span></p><h2 style="padding-left: 138pt;text-indent: 0pt;line-height: 55pt;text-align: left;">认识Module</h2><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="text-indent: 0pt;text-align: left;"><span><img width="1119" height="6" alt="image" src="index_files/Image_115.png"/></span><span><img width="475" height="451" alt="image" src="index_files/Image_116.gif"/></span></p></li><li><p style="padding-top: 1pt;padding-left: 35pt;text-indent: -18pt;text-align: justify;">Module是模块的意思, 为什么在Vuex中我们要使用模块呢?</p><ul id="l42"><li><p style="padding-top: 5pt;padding-left: 60pt;text-indent: -21pt;text-align: justify;"><span>Vue使用单一状态树,那么也意味着很多状态都会交给<br/>Vuex来管理.</span></p></li><li><p style="padding-top: 5pt;padding-left: 60pt;text-indent: -21pt;text-align: justify;"><span>当应用变得非常复杂时,store对象就有可能变得相当臃<br/>肿.</span></p></li><li><p style="padding-top: 4pt;padding-left: 60pt;text-indent: -21pt;text-align: justify;"><span>为了解决这个问题, Vuex允许我们将store分割成模块<br/>(Module), 而每个模块拥有自己的state、mutation、<br/>action、getters等</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p></li></ul></li><li><p style="padding-left: 35pt;text-indent: -18pt;text-align: justify;">我们按照什么样的方式来组织模块呢?</p><ul id="l43"><li><p style="padding-top: 5pt;padding-left: 60pt;text-indent: -21pt;text-align: left;">我们来看左边的代码</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="text-indent: 0pt;text-align: left;"/><p style="text-indent: 0pt;text-align: left;"><span><img width="1119" height="7" alt="image" src="index_files/Image_117.png"/></span></p><p style="text-indent: 0pt;text-align: left;"><span><img width="141" height="50" alt="image" src="index_files/Image_118.jpg"/></span></p><h2 style="padding-left: 138pt;text-indent: 0pt;line-height: 55pt;text-align: left;">Module局部状态</h2><p style="text-indent: 0pt;text-align: left;"><br/></p></li></ul></li><li><p style="padding-top: 1pt;padding-left: 35pt;text-indent: -18pt;text-align: left;">上面的代码中, 我们已经有了整体的组织结构, 下面我们来看看具体的局部模块中的代码如何书写.</p><ul id="l44"><li><p style="padding-top: 5pt;padding-left: 60pt;text-indent: -21pt;text-align: left;">我们在moduleA中添加state、mutations、getters</p><p style="text-indent: 0pt;text-align: left;"><span><img width="309" height="364" alt="image" src="index_files/Image_119.gif"/></span></p><p style="text-indent: 0pt;text-align: left;"><span><img width="405" height="351" alt="image" src="index_files/Image_120.gif"/></span></p></li><li><p style="padding-top: 5pt;padding-left: 60pt;text-indent: -21pt;text-align: left;">mutation和getters接收的第一个参数是局部状态对象</p><p style="text-indent: 0pt;text-align: left;"><br/></p><ul id="l45"><li><p class="s14" style="padding-left: 599pt;text-indent: -19pt;text-align: left;">注意<span class="s15">:</span></p><ul id="l46"><li><p class="s14" style="padding-top: 8pt;padding-left: 599pt;text-indent: -19pt;text-align: left;">虽然<span class="s15">, </span>我们的<span class="s15">doubleCount</span>和</p><p class="s15" style="padding-top: 8pt;padding-left: 599pt;text-indent: 0pt;text-align: left;">increment<span class="s14">都是定义在对象内部的</span>.</p></li><li><p class="s14" style="padding-top: 8pt;padding-left: 599pt;text-indent: -19pt;text-align: left;">但是在调用的时候<span class="s15">, </span>依然是通过</p></li></ul><p style="text-indent: 0pt;text-align: left;"><span><img width="1119" height="6" alt="image" src="index_files/Image_121.png"/></span></p><p class="s15" style="padding-top: 8pt;padding-left: 599pt;text-indent: 0pt;text-align: left;">this.$store<span class="s14">来直接调用的</span>.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="text-indent: 0pt;text-align: left;"/><p style="text-indent: 0pt;text-align: left;"><span><img width="1119" height="7" alt="image" src="index_files/Image_122.png"/></span></p><p style="text-indent: 0pt;text-align: left;"><span><img width="141" height="50" alt="image" src="index_files/Image_123.jpg"/></span></p><h2 style="padding-left: 138pt;text-indent: 0pt;line-height: 55pt;text-align: left;">Actions的写法</h2><p style="text-indent: 0pt;text-align: left;"><br/></p></li></ul></li></ul></li><li><p style="padding-top: 1pt;padding-left: 35pt;text-indent: -18pt;text-align: left;">actions的写法呢? 接收一个context参数对象</p><ul id="l47"><li><p style="padding-top: 5pt;padding-bottom: 3pt;padding-left: 60pt;text-indent: -21pt;text-align: left;">局部状态通过 context.state 暴露出来，根节点状态则为 context.rootState</p><p style="padding-left: 43pt;text-indent: 0pt;text-align: left;"><span><img width="548" height="198" alt="image" src="index_files/Image_124.gif"/></span></p><p style="text-indent: 0pt;text-align: left;"><span><img width="1119" height="6" alt="image" src="index_files/Image_125.png"/></span></p></li></ul></li><li><p style="padding-top: 7pt;padding-left: 35pt;text-indent: -18pt;text-align: left;">如果getters中也需要使用全局的状态, 可以接受更多的参数</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 43pt;text-indent: 0pt;text-align: left;"><span><img width="410" height="160" alt="image" src="index_files/Image_126.gif"/></span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="text-indent: 0pt;text-align: left;"/><p style="text-indent: 0pt;text-align: left;"><span><img width="1119" height="7" alt="image" src="index_files/Image_127.png"/></span></p><p style="text-indent: 0pt;text-align: left;"><span><img width="141" height="50" alt="image" src="index_files/Image_128.jpg"/></span></p><h2 style="padding-left: 138pt;text-indent: 0pt;line-height: 55pt;text-align: left;">项目结构</h2><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="text-indent: 0pt;text-align: left;"><span><img width="1119" height="6" alt="image" src="index_files/Image_129.png"/></span></p></li><li><p style="padding-top: 1pt;padding-left: 35pt;text-indent: -18pt;text-align: left;">当我们的Vuex帮助我们管理过多的内容时, 好的项目结构可以让我们的代码更加清晰.</p></li></ul></li></ul><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 34pt;text-indent: 0pt;text-align: left;"><span><img width="588" height="292" alt="image" src="index_files/Image_130.gif"/></span></p></body></html>
