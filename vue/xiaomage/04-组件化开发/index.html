<!DOCTYPE  html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="zh" lang="zh"><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"/><title>&lt;30342DD7E9BCFEBBAFBFAAB7A22E70707478&gt;</title><meta name="author" content="lala"/><style type="text/css"> * {margin:0; padding:0; text-indent:0; }
 h1 { color: black; font-family:微软雅黑, sans-serif; font-style: normal; font-weight: bold; text-decoration: none; font-size: 57pt; }
 .p, p { color: #585858; font-family:微软雅黑, sans-serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 15.5pt; margin:0pt; }
 .a, a { color: black; font-family:微软雅黑, sans-serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 14pt; }
 .s2 { color: black; font-family:"Times New Roman", serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 10pt; }
 .h2 { color: #3F3F3F; font-family:微软雅黑, sans-serif; font-style: normal; font-weight: bold; text-decoration: none; font-size: 31.5pt; }
 .s3 { color: #585858; font-family:微软雅黑, sans-serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 14pt; }
 .s4 { color: black; font-family:宋体; font-style: normal; font-weight: normal; text-decoration: none; font-size: 15.5pt; }
 .s5 { color: #585858; font-family:微软雅黑, sans-serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 14.5pt; }
 h3 { color: #585858; font-family:微软雅黑, sans-serif; font-style: normal; font-weight: bold; text-decoration: none; font-size: 15.5pt; }
 .s6 { color: black; font-family:微软雅黑, sans-serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 10pt; }
 .s7 { color: black; font-family:微软雅黑, sans-serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 15.5pt; }
 .s8 { color: #585858; font-family:微软雅黑, sans-serif; font-style: normal; font-weight: normal; text-decoration: underline; font-size: 15.5pt; }
 .s9 { color: #585858; font-family:微软雅黑, sans-serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 13pt; }
 li {display: block; }
 #l1 {padding-left: 0pt; }
 #l1> li>*:first-child:before {content: " "; color: black; font-family:Wingdings; font-style: normal; font-weight: normal; text-decoration: none; }
 #l2 {padding-left: 0pt; }
 #l2> li>*:first-child:before {content: " "; color: black; font-family:Wingdings; font-style: normal; font-weight: normal; text-decoration: none; }
 #l3 {padding-left: 0pt; }
 #l3> li>*:first-child:before {content: " "; color: black; font-family:Wingdings; font-style: normal; font-weight: normal; text-decoration: none; font-size: 15.5pt; }
 #l4 {padding-left: 0pt; }
 #l4> li>*:first-child:before {content: " "; color: black; font-family:Wingdings; font-style: normal; font-weight: normal; text-decoration: none; }
 #l5 {padding-left: 0pt; }
 #l5> li>*:first-child:before {content: " "; color: black; font-family:Wingdings; font-style: normal; font-weight: normal; text-decoration: none; }
 #l6 {padding-left: 0pt; }
 #l6> li>*:first-child:before {content: " "; color: black; font-family:Wingdings; font-style: normal; font-weight: normal; text-decoration: none; }
 #l7 {padding-left: 0pt; }
 #l7> li>*:first-child:before {content: " "; color: black; font-family:Wingdings; font-style: normal; font-weight: normal; text-decoration: none; }
 #l8 {padding-left: 0pt; }
 #l8> li>*:first-child:before {content: " "; color: black; font-family:Wingdings; font-style: normal; font-weight: normal; text-decoration: none; }
 #l9 {padding-left: 0pt; }
 #l9> li>*:first-child:before {content: " "; color: black; font-family:Wingdings; font-style: normal; font-weight: normal; text-decoration: none; }
 #l10 {padding-left: 0pt; }
 #l10> li>*:first-child:before {content: " "; color: black; font-family:Wingdings; font-style: normal; font-weight: normal; text-decoration: none; }
 #l11 {padding-left: 0pt; }
 #l11> li>*:first-child:before {content: " "; color: black; font-family:Wingdings; font-style: normal; font-weight: normal; text-decoration: none; }
 #l12 {padding-left: 0pt; }
 #l12> li>*:first-child:before {content: " "; color: black; font-family:Wingdings; font-style: normal; font-weight: normal; text-decoration: none; }
 #l13 {padding-left: 0pt; }
 #l13> li>*:first-child:before {content: " "; color: black; font-family:Wingdings; font-style: normal; font-weight: normal; text-decoration: none; }
 #l14 {padding-left: 0pt; }
 #l14> li>*:first-child:before {content: " "; color: black; font-family:Wingdings; font-style: normal; font-weight: normal; text-decoration: none; }
 #l15 {padding-left: 0pt; }
 #l15> li>*:first-child:before {content: " "; color: black; font-family:Wingdings; font-style: normal; font-weight: normal; text-decoration: none; }
 #l16 {padding-left: 0pt; }
 #l16> li>*:first-child:before {content: " "; color: black; font-family:Wingdings; font-style: normal; font-weight: normal; text-decoration: none; }
 #l17 {padding-left: 0pt; }
 #l17> li>*:first-child:before {content: " "; color: black; font-family:Wingdings; font-style: normal; font-weight: normal; text-decoration: none; }
 #l18 {padding-left: 0pt; }
 #l18> li>*:first-child:before {content: " "; color: black; font-family:Wingdings; font-style: normal; font-weight: normal; text-decoration: none; }
 #l19 {padding-left: 0pt; }
 #l19> li>*:first-child:before {content: " "; color: black; font-family:Wingdings; font-style: normal; font-weight: normal; text-decoration: none; font-size: 15.5pt; }
 #l20 {padding-left: 0pt; }
 #l20> li>*:first-child:before {content: " "; color: black; font-family:Wingdings; font-style: normal; font-weight: normal; text-decoration: none; }
 #l21 {padding-left: 0pt; }
 #l21> li>*:first-child:before {content: " "; color: black; font-family:Wingdings; font-style: normal; font-weight: normal; text-decoration: none; }
 #l22 {padding-left: 0pt; }
 #l22> li>*:first-child:before {content: " "; color: black; font-family:Wingdings; font-style: normal; font-weight: normal; text-decoration: none; }
 #l23 {padding-left: 0pt; }
 #l23> li>*:first-child:before {content: " "; color: black; font-family:Wingdings; font-style: normal; font-weight: normal; text-decoration: none; }
 #l24 {padding-left: 0pt; }
 #l24> li>*:first-child:before {content: " "; color: black; font-family:Wingdings; font-style: normal; font-weight: normal; text-decoration: none; }
 #l25 {padding-left: 0pt; }
 #l25> li>*:first-child:before {content: " "; color: black; font-family:Wingdings; font-style: normal; font-weight: normal; text-decoration: none; }
 #l26 {padding-left: 0pt; }
 #l26> li>*:first-child:before {content: " "; color: black; font-family:Wingdings; font-style: normal; font-weight: normal; text-decoration: none; }
 #l27 {padding-left: 0pt; }
 #l27> li>*:first-child:before {content: " "; color: black; font-family:Wingdings; font-style: normal; font-weight: normal; text-decoration: none; }
 #l28 {padding-left: 0pt; }
 #l28> li>*:first-child:before {content: " "; color: black; font-family:Wingdings; font-style: normal; font-weight: normal; text-decoration: none; }
 #l29 {padding-left: 0pt; }
 #l29> li>*:first-child:before {content: " "; color: black; font-family:Wingdings; font-style: normal; font-weight: normal; text-decoration: none; }
 #l30 {padding-left: 0pt; }
 #l30> li>*:first-child:before {content: " "; color: black; font-family:Wingdings; font-style: normal; font-weight: normal; text-decoration: none; }
 #l31 {padding-left: 0pt; }
 #l31> li>*:first-child:before {content: " "; color: black; font-family:Wingdings; font-style: normal; font-weight: normal; text-decoration: none; }
 #l32 {padding-left: 0pt; }
 #l32> li>*:first-child:before {content: " "; color: black; font-family:Wingdings; font-style: normal; font-weight: normal; text-decoration: none; }
 #l33 {padding-left: 0pt; }
 #l33> li>*:first-child:before {content: " "; color: black; font-family:Wingdings; font-style: normal; font-weight: normal; text-decoration: none; }
 #l34 {padding-left: 0pt; }
 #l34> li>*:first-child:before {content: " "; color: black; font-family:Wingdings; font-style: normal; font-weight: normal; text-decoration: none; }
 #l35 {padding-left: 0pt; }
 #l35> li>*:first-child:before {content: " "; color: black; font-family:Wingdings; font-style: normal; font-weight: normal; text-decoration: none; }
 #l36 {padding-left: 0pt; }
 #l36> li>*:first-child:before {content: " "; color: black; font-family:Wingdings; font-style: normal; font-weight: normal; text-decoration: none; }
 #l37 {padding-left: 0pt; }
 #l37> li>*:first-child:before {content: " "; color: black; font-family:Wingdings; font-style: normal; font-weight: normal; text-decoration: none; }
 #l38 {padding-left: 0pt; }
 #l38> li>*:first-child:before {content: " "; color: black; font-family:Wingdings; font-style: normal; font-weight: normal; text-decoration: none; }
 #l39 {padding-left: 0pt; }
 #l39> li>*:first-child:before {content: " "; color: black; font-family:Wingdings; font-style: normal; font-weight: normal; text-decoration: none; }
 #l40 {padding-left: 0pt; }
 #l40> li>*:first-child:before {content: " "; color: black; font-family:Wingdings; font-style: normal; font-weight: normal; text-decoration: none; }
 #l41 {padding-left: 0pt; }
 #l41> li>*:first-child:before {content: " "; color: black; font-family:Wingdings; font-style: normal; font-weight: normal; text-decoration: none; }
 #l42 {padding-left: 0pt; }
 #l42> li>*:first-child:before {content: " "; color: black; font-family:Wingdings; font-style: normal; font-weight: normal; text-decoration: none; }
 #l43 {padding-left: 0pt; }
 #l43> li>*:first-child:before {content: " "; color: black; font-family:Wingdings; font-style: normal; font-weight: normal; text-decoration: none; }
 #l44 {padding-left: 0pt; }
 #l44> li>*:first-child:before {content: " "; color: black; font-family:Wingdings; font-style: normal; font-weight: normal; text-decoration: none; }
 #l45 {padding-left: 0pt; }
 #l45> li>*:first-child:before {content: " "; color: black; font-family:Wingdings; font-style: normal; font-weight: normal; text-decoration: none; }
 #l46 {padding-left: 0pt; }
 #l46> li>*:first-child:before {content: " "; color: black; font-family:Wingdings; font-style: normal; font-weight: normal; text-decoration: none; }
 #l47 {padding-left: 0pt; }
 #l47> li>*:first-child:before {content: " "; color: black; font-family:Wingdings; font-style: normal; font-weight: normal; text-decoration: none; }
 #l48 {padding-left: 0pt; }
 #l48> li>*:first-child:before {content: " "; color: black; font-family:Wingdings; font-style: normal; font-weight: normal; text-decoration: none; }
 #l49 {padding-left: 0pt; }
 #l49> li>*:first-child:before {content: " "; color: black; font-family:Wingdings; font-style: normal; font-weight: normal; text-decoration: none; }
 #l50 {padding-left: 0pt; }
 #l50> li>*:first-child:before {content: " "; color: black; font-family:Wingdings; font-style: normal; font-weight: normal; text-decoration: none; }
 #l51 {padding-left: 0pt; }
 #l51> li>*:first-child:before {content: " "; color: #585858; font-family:Wingdings; font-style: normal; font-weight: normal; text-decoration: none; font-size: 15.5pt; }
 #l52 {padding-left: 0pt; }
 #l52> li>*:first-child:before {content: " "; color: #585858; font-family:Wingdings; font-style: normal; font-weight: normal; text-decoration: none; font-size: 15.5pt; }
 #l53 {padding-left: 0pt; }
 #l53> li>*:first-child:before {content: " "; color: black; font-family:Wingdings; font-style: normal; font-weight: normal; text-decoration: none; }
</style></head><body><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="text-indent: 0pt;text-align: left;"><span><img width="1117" height="22" alt="image" src="index_files/Image_001.png"/></span></p><h1 style="padding-left: 277pt;text-indent: 0pt;line-height: 95pt;text-align: center;">组件化开发</h1><p style="padding-top: 17pt;padding-left: 277pt;text-indent: 0pt;line-height: 27pt;text-align: center;">王红元</p><p style="padding-left: 359pt;text-indent: -9pt;line-height: 90%;text-align: center;"><span>微博：coderwhy<br/>微信：372623326</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 368pt;text-indent: 0pt;text-align: left;"><span><img width="140" height="50" alt="image" src="index_files/Image_002.jpg"/></span></p><p style="text-indent: 0pt;text-align: left;"><span><img width="1117" height="22" alt="image" src="index_files/Image_003.png"/></span></p><p style="padding-left: 277pt;text-indent: 0pt;text-align: center;"><a href="http://www.520it.com/" class="a" target="_blank">实力IT教育 </a><a href="http://www.520it.com/" target="_blank">www.520it.com</a></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="text-indent: 0pt;text-align: left;"><span><img width="1119" height="7" alt="image" src="index_files/Image_004.png"/></span></p><p style="text-indent: 0pt;text-align: left;"/><p class="s2" style="padding-left: 13pt;text-indent: 0pt;line-height: 55pt;text-align: left;"><span><img width="141" height="50" alt="image" src="index_files/Image_005.jpg"/></span>        <span class="h2">内容概述</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><ul id="l1"><li><p style="padding-top: 1pt;padding-left: 33pt;text-indent: -15pt;text-align: left;">认识组件化</p></li><li><p style="padding-top: 2pt;padding-left: 33pt;text-indent: -15pt;text-align: left;">注册组件</p></li><li><p style="padding-top: 2pt;padding-left: 33pt;text-indent: -15pt;text-align: left;">组件其他补充</p></li><li><p style="padding-top: 2pt;padding-left: 33pt;text-indent: -15pt;text-align: left;">组件数据存放</p></li><li><p style="padding-top: 2pt;padding-left: 33pt;text-indent: -15pt;text-align: left;">父子组件通信</p></li><li><p style="padding-top: 2pt;padding-left: 33pt;text-indent: -15pt;text-align: left;">父级向子级传递</p></li><li><p style="padding-top: 2pt;padding-left: 33pt;text-indent: -15pt;text-align: left;">子级向父级传递</p><p style="text-indent: 0pt;text-align: left;"><span><img width="1119" height="6" alt="image" src="index_files/Image_006.png"/></span></p></li><li><p style="padding-top: 2pt;padding-left: 33pt;text-indent: -15pt;text-align: left;">插槽slot</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="text-indent: 0pt;text-align: left;"><span><img width="1119" height="7" alt="image" src="index_files/Image_007.png"/></span></p><p style="text-indent: 0pt;text-align: left;"/><p class="s2" style="padding-left: 13pt;text-indent: 0pt;line-height: 55pt;text-align: left;"><span><img width="141" height="50" alt="image" src="index_files/Image_008.jpg"/></span>        <span class="h2">什么是组件化？</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p></li><li><p class="s3" style="padding-top: 1pt;padding-left: 33pt;text-indent: -15pt;text-align: left;">人面对复杂问题的处理方式：</p><p style="text-indent: 0pt;text-align: left;"><span><img width="461" height="190" alt="image" src="index_files/Image_009.jpg"/></span></p><ul id="l2"><li><p class="s3" style="padding-left: 64pt;text-indent: -15pt;text-align: left;">任何一个人处理信息的逻辑能力都是有限的</p></li><li><p class="s3" style="padding-top: 3pt;padding-left: 64pt;text-indent: -15pt;line-height: 85%;text-align: left;"><span>所以，当面对一个非常复杂的问题时，我们不太可能一                                                                                                                                                            <br/>次性搞定一大堆的内容。</span></p></li><li><p class="s3" style="padding-top: 1pt;padding-left: 64pt;text-indent: -15pt;text-align: left;">但是，我们人有一种天生的能力，就是将问题进行拆解。</p><p style="text-indent: 0pt;text-align: left;"><span><img width="151" height="250" alt="image" src="index_files/Image_010.jpg"/></span></p></li><li><p class="s3" style="padding-top: 3pt;padding-left: 64pt;text-indent: -15pt;line-height: 85%;text-align: justify;"><span>如果将一个复杂的问题，拆分成很多个可以处理的小问 <br/>题，再将其放在整体当中，你会发现大的问题也会迎刃<br/>而解。</span></p><ul id="l3"><li><p class="s4" style="padding-top: 2pt;padding-left: 29pt;text-indent: -23pt;text-align: left;"><span>我们将一个完整的页面<br/>分成很多个组件。</span></p></li><li><p class="s4" style="padding-left: 29pt;text-indent: -23pt;text-align: left;"><span>每个组件都用于实现页<br/>面的一个功能块。</span></p></li><li><p class="s4" style="padding-left: 29pt;text-indent: -23pt;text-align: left;"><span>而每一个组件又可以进<br/>行细分。</span></p></li></ul><p style="text-indent: 0pt;text-align: left;"/></li></ul></li><li><p class="s3" style="padding-top: 5pt;padding-left: 33pt;text-indent: -15pt;line-height: 26pt;text-align: justify;">组件化也是类似的思想：</p><ul id="l4"><li><p class="s5" style="padding-top: 3pt;padding-left: 64pt;text-indent: -15pt;line-height: 82%;text-align: justify;"><span>如果我们将一个页面中所有的处理逻辑全部放在一<br/>起，处理起来就会变得非常复杂，而且不利于后续<br/>的管理以及扩展。</span></p><p style="text-indent: 0pt;text-align: left;"><span><img width="1119" height="6" alt="image" src="index_files/Image_011.png"/></span></p></li><li><p class="s5" style="padding-top: 4pt;padding-left: 64pt;text-indent: -15pt;line-height: 82%;text-align: left;"><span>但如果，我们讲一个页面拆分成一个个小的功能块，<br/>每个功能块完成属于自己这部分独立的功能，那么<br/>之后整个页面的管理和维护就变得非常容易了。</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="text-indent: 0pt;text-align: left;"><span><img width="1119" height="7" alt="image" src="index_files/Image_012.png"/></span></p><p style="text-indent: 0pt;text-align: left;"/><p class="s2" style="padding-left: 13pt;text-indent: 0pt;line-height: 55pt;text-align: left;"><span><img width="141" height="50" alt="image" src="index_files/Image_013.jpg"/></span>        <span class="h2">Vue组件化思想</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p></li></ul></li><li><p class="s3" style="padding-top: 1pt;padding-left: 33pt;text-indent: -15pt;text-align: left;">组件化是Vue.js中的重要思想</p><ul id="l5"><li><p class="s3" style="padding-left: 64pt;text-indent: -15pt;text-align: left;">它提供了一种抽象，让我们可以开发出一个个独立可复用的小组件来构造我们的应用。</p><p style="text-indent: 0pt;text-align: left;"><span><img width="546" height="144" alt="image" src="index_files/Image_014.png"/></span></p></li><li><p class="s3" style="padding-left: 64pt;text-indent: -15pt;text-align: left;">任何的应用都会被抽象成一颗组件树。</p><p style="text-indent: 0pt;text-align: left;"><br/></p></li></ul></li><li><p class="s3" style="padding-left: 33pt;text-indent: -15pt;text-align: left;">组件化思想的应用：</p><ul id="l6"><li><p class="s3" style="padding-left: 64pt;text-indent: -15pt;text-align: left;">有了组件化的思想，我们在之后的开发中就要充分的利用它。</p></li><li><p class="s3" style="padding-left: 64pt;text-indent: -15pt;text-align: left;">尽可能的将页面拆分成一个个小的、可复用的组件。</p></li><li><p class="s3" style="padding-left: 64pt;text-indent: -15pt;text-align: left;">这样让我们的代码更加方便组织和管理，并且扩展性也更强。</p><p style="text-indent: 0pt;text-align: left;"><span><img width="1119" height="6" alt="image" src="index_files/Image_015.png"/></span></p></li></ul></li><li><p class="s3" style="padding-top: 4pt;padding-left: 33pt;text-indent: -15pt;text-align: left;">所以，组件是Vue开发中，非常重要的一个篇章，要认真学习。</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="text-indent: 0pt;text-align: left;"><span><img width="1119" height="7" alt="image" src="index_files/Image_016.png"/></span></p><p style="text-indent: 0pt;text-align: left;"/><p class="s2" style="padding-left: 13pt;text-indent: 0pt;line-height: 55pt;text-align: left;"><span><img width="141" height="50" alt="image" src="index_files/Image_017.jpg"/></span>        <span class="h2">注册组件的基本步骤</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="text-indent: 0pt;text-align: left;"><span><img width="221" height="370" alt="image" src="index_files/Image_018.jpg"/></span><span><img width="373" height="346" alt="image" src="index_files/Image_019.jpg"/></span><span><img width="247" height="72" alt="image" src="index_files/Image_020.jpg"/></span></p></li><li><p class="s3" style="padding-top: 1pt;padding-left: 33pt;text-indent: -15pt;text-align: left;">组件的使用分成三个步骤：</p><ul id="l7"><li><p class="s3" style="padding-left: 64pt;text-indent: -15pt;text-align: left;">创建组件构造器</p></li><li><p class="s3" style="padding-left: 64pt;text-indent: -15pt;text-align: left;">注册组件</p></li><li><p class="s3" style="padding-left: 64pt;text-indent: -15pt;text-align: left;">使用组件。</p></li></ul></li><li><p class="s3" style="padding-top: 4pt;padding-left: 33pt;text-indent: -15pt;text-align: left;">我们来看看通过代码如何注册组件</p></li><li><p class="s3" style="padding-top: 4pt;padding-left: 33pt;text-indent: -15pt;text-align: left;">查看运行结果：</p><ul id="l8"><li><p class="s3" style="padding-top: 3pt;padding-left: 64pt;text-indent: -15pt;line-height: 85%;text-align: left;"><span>和直接使用一个div看起来并没有<br/>什么区别。</span></p><p style="text-indent: 0pt;text-align: left;"><span><img width="1119" height="6" alt="image" src="index_files/Image_021.png"/></span></p></li><li><p class="s3" style="padding-top: 4pt;padding-left: 64pt;text-indent: -15pt;line-height: 85%;text-align: left;"><span>但是我们可以设想，如果很多地                                                                                         <br/>方都要显示这样的信息，我们是<br/>不是就可以直接使用&lt;my-<br/>cpn&gt;&lt;/my-cpn&gt;来完成呢？</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="text-indent: 0pt;text-align: left;"><span><img width="1119" height="7" alt="image" src="index_files/Image_022.png"/></span></p><p style="text-indent: 0pt;text-align: left;"/><p class="s2" style="padding-left: 13pt;text-indent: 0pt;line-height: 55pt;text-align: left;"><span><img width="141" height="50" alt="image" src="index_files/Image_023.jpg"/></span>        <span class="h2">注册组件步骤解析</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p></li></ul></li><li><p class="s3" style="padding-top: 1pt;padding-left: 33pt;text-indent: -15pt;text-align: left;">这里的步骤都代表什么含义呢？</p></li><li><p class="s3" style="padding-top: 4pt;padding-left: 33pt;text-indent: -15pt;text-align: left;">1.Vue.extend()：</p><ul id="l9"><li><p class="s3" style="padding-left: 64pt;text-indent: -15pt;text-align: left;">调用Vue.extend()创建的是一个组件构造器。</p></li><li><p class="s3" style="padding-left: 64pt;text-indent: -15pt;text-align: left;">通常在创建组件构造器时，传入template代表我们自定义组件的模板。</p></li><li><p class="s3" style="padding-left: 64pt;text-indent: -15pt;text-align: left;">该模板就是在使用到组件的地方，要显示的HTML代码。</p></li><li><p class="s3" style="padding-top: 3pt;padding-left: 64pt;text-indent: -15pt;line-height: 85%;text-align: left;"><span>事实上，这种写法在Vue2.x的文档中几乎已经看不到了，它会直接使用下面我们会讲到的语法糖，但是在很多资料还是会<br/>提到这种方式，而且这种方式是学习后面方式的基础。</span></p></li></ul></li><li><p class="s3" style="padding-top: 6pt;padding-left: 33pt;text-indent: -15pt;text-align: left;">2.Vue.component()：</p><ul id="l10"><li><p class="s3" style="padding-left: 64pt;text-indent: -15pt;text-align: left;">调用Vue.component()是将刚才的组件构造器注册为一个组件，并且给它起一个组件的标签名称。</p></li><li><p class="s3" style="padding-left: 64pt;text-indent: -15pt;text-align: left;">所以需要传递两个参数：1、注册组件的标签名 2、组件构造器</p></li></ul></li><li><p class="s3" style="padding-top: 4pt;padding-left: 33pt;text-indent: -15pt;text-align: left;">3.组件必须挂载在某个Vue实例下，否则它不会生效。（见下页）</p><ul id="l11"><li><p class="s3" style="padding-left: 64pt;text-indent: -15pt;text-align: left;">我们来看下面我使用了三次&lt;my-cpn&gt;&lt;/my-cpn&gt;</p><p style="text-indent: 0pt;text-align: left;"><span><img width="1119" height="6" alt="image" src="index_files/Image_024.png"/></span></p></li><li><p class="s3" style="padding-left: 64pt;text-indent: -15pt;text-align: left;">而第三次其实并没有生效：</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="text-indent: 0pt;text-align: left;"><span><img width="1119" height="7" alt="image" src="index_files/Image_025.png"/></span></p><p style="text-indent: 0pt;text-align: left;"><span><img width="1119" height="6" alt="image" src="index_files/Image_026.png"/></span></p><p style="text-indent: 0pt;text-align: left;"/><p class="s2" style="padding-left: 13pt;text-indent: 0pt;line-height: 55pt;text-align: left;"><span><img width="141" height="50" alt="image" src="index_files/Image_027.jpg"/></span>        <span class="h2">第三步的解析</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 27pt;text-indent: 0pt;text-align: left;"><span><img width="981" height="361" alt="image" src="index_files/Image_028.jpg"/></span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="text-indent: 0pt;text-align: left;"><span><img width="1119" height="7" alt="image" src="index_files/Image_029.png"/></span></p><p style="text-indent: 0pt;text-align: left;"/><p class="s2" style="padding-left: 13pt;text-indent: 0pt;line-height: 55pt;text-align: left;"><span><img width="141" height="50" alt="image" src="index_files/Image_030.jpg"/></span>        <span class="h2">全局组件和局部组件</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p></li></ul></li><li><p style="padding-top: 1pt;padding-left: 33pt;text-indent: -15pt;line-height: 27pt;text-align: left;">当我们通过<b>调用Vue.component()注册组件时，组件的注册是全局的</b></p><ul id="l12"><li><h3 style="padding-left: 64pt;text-indent: -15pt;line-height: 27pt;text-align: left;">这意味着该组件可以在任意Vue示例下使用。</h3><p style="text-indent: 0pt;text-align: left;"><span><img width="1119" height="6" alt="image" src="index_files/Image_031.png"/></span></p></li></ul></li><li><p style="padding-top: 2pt;padding-bottom: 1pt;padding-left: 33pt;text-indent: -15pt;text-align: left;">如果我们注册的组件是挂载在某个实例中, 那么就是一个局部组件</p><p class="s6" style="padding-left: 37pt;text-indent: 0pt;text-align: left;"><span><img width="424" height="375" alt="image" src="index_files/Image_032.jpg"/></span>	<span><img width="395" height="370" alt="image" src="index_files/Image_033.jpg"/></span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="text-indent: 0pt;text-align: left;"><span><img width="1119" height="7" alt="image" src="index_files/Image_034.png"/></span></p><p style="text-indent: 0pt;text-align: left;"/><p class="s2" style="padding-left: 13pt;text-indent: 0pt;line-height: 55pt;text-align: left;"><span><img width="141" height="50" alt="image" src="index_files/Image_035.jpg"/></span>        <span class="h2">父组件和子组件</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="text-indent: 0pt;text-align: left;"><span><img width="477" height="468" alt="image" src="index_files/Image_036.jpg"/></span></p></li><li><p class="s3" style="padding-top: 1pt;padding-left: 33pt;text-indent: -15pt;text-align: left;">在前面我们看到了组件树：</p><ul id="l13"><li><p class="s3" style="padding-left: 64pt;text-indent: -15pt;text-align: left;">组件和组件之间存在层级关系</p></li><li><p class="s3" style="padding-left: 64pt;text-indent: -15pt;text-align: left;">而其中一种非常重要的关系就是父子组件的关系</p></li></ul></li><li><p class="s3" style="padding-top: 4pt;padding-left: 33pt;text-indent: -15pt;text-align: left;">我们来看通过代码如何组成的这种层级关系：</p><p style="text-indent: 0pt;text-align: left;"><br/></p></li><li><p class="s3" style="padding-left: 33pt;text-indent: -15pt;text-align: left;">父子组件错误用法：以子标签的形式在Vue实例中使用</p><ul id="l14"><li><p class="s3" style="padding-top: 3pt;padding-left: 64pt;text-indent: -15pt;line-height: 85%;text-align: left;"><span>因为当子组件注册到父组件的components时，Vue会编<br/>译好父组件的模块</span></p></li><li><p class="s3" style="padding-top: 4pt;padding-left: 64pt;text-indent: -15pt;line-height: 85%;text-align: left;"><span>该模板的内容已经决定了父组件将要渲染的HTML（相当<br/>于父组件中已经有了子组件中的内容了）</span></p></li><li><p class="s3" style="padding-top: 1pt;padding-left: 64pt;text-indent: -15pt;text-align: left;">&lt;child-cpn&gt;&lt;/child-cpn&gt;是只能在父组件中被识别的。</p><p style="text-indent: 0pt;text-align: left;"><span><img width="1119" height="6" alt="image" src="index_files/Image_037.png"/></span></p></li><li><p class="s3" style="padding-top: 3pt;padding-left: 64pt;text-indent: -15pt;line-height: 85%;text-align: left;"><span>类似这种用法，&lt;child-cpn&gt;&lt;/child-cpn&gt;是会被浏览器<br/>忽略的。</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="text-indent: 0pt;text-align: left;"><span><img width="1119" height="7" alt="image" src="index_files/Image_038.png"/></span></p><p style="text-indent: 0pt;text-align: left;"/><p class="s2" style="padding-left: 13pt;text-indent: 0pt;line-height: 55pt;text-align: left;"><span><img width="141" height="50" alt="image" src="index_files/Image_039.jpg"/></span>        <span class="h2">注册组件语法糖</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p></li></ul></li><li><p style="padding-top: 1pt;padding-left: 33pt;text-indent: -15pt;line-height: 27pt;text-align: left;">在上面注册组件的方式，可能会有些繁琐。</p><ul id="l15"><li><p style="padding-left: 64pt;text-indent: -15pt;line-height: 26pt;text-align: left;">Vue为了简化这个过程，提供了注册的语法糖。</p></li><li><p style="padding-left: 64pt;text-indent: -15pt;line-height: 27pt;text-align: left;">主要是省去了调用Vue.extend()的步骤，而是可以直接使用一个对象来代替。</p><p style="text-indent: 0pt;text-align: left;"><span><img width="1119" height="6" alt="image" src="index_files/Image_040.png"/></span></p><p style="text-indent: 0pt;text-align: left;"><span><img width="458" height="146" alt="image" src="index_files/Image_041.jpg"/></span><span><img width="458" height="192" alt="image" src="index_files/Image_042.jpg"/></span></p></li></ul></li><li><h3 style="padding-top: 2pt;padding-left: 33pt;text-indent: -15pt;text-align: left;">语法糖注册全局组件和局部组件<span class="p">：</span></h3><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="text-indent: 0pt;text-align: left;"><span><img width="1119" height="7" alt="image" src="index_files/Image_043.png"/></span></p><p style="text-indent: 0pt;text-align: left;"/><p class="s2" style="padding-left: 13pt;text-indent: 0pt;line-height: 55pt;text-align: left;"><span><img width="141" height="50" alt="image" src="index_files/Image_044.jpg"/></span>        <span class="h2">模板的分离写法</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p></li><li><p style="padding-top: 1pt;padding-left: 33pt;text-indent: -15pt;text-align: left;">刚才，我们通过语法糖简化了Vue组件的注册过程，另外还有一个地方的写法比较麻烦，就是template模块写法。</p></li><li><p style="padding-top: 2pt;padding-left: 33pt;text-indent: -15pt;text-align: left;">如果我们能将其中的HTML分离出来写，然后挂载到对应的组件上，必然结构会变得非常清晰。</p></li><li><p style="padding-top: 2pt;padding-left: 33pt;text-indent: -15pt;line-height: 27pt;text-align: left;">Vue提供了两种方案来定义HTML模块内容：</p><ul id="l16"><li><p style="padding-left: 64pt;text-indent: -15pt;line-height: 26pt;text-align: left;">使用&lt;script&gt;标签</p><p style="text-indent: 0pt;text-align: left;"><span><img width="1119" height="6" alt="image" src="index_files/Image_045.png"/></span></p></li><li><p style="padding-bottom: 1pt;padding-left: 64pt;text-indent: -15pt;line-height: 27pt;text-align: left;">使用&lt;template&gt;标签</p><p class="s6" style="padding-left: 40pt;text-indent: 0pt;text-align: left;"><span><img width="309" height="300" alt="image" src="index_files/Image_046.jpg"/></span>	<span><img width="277" height="300" alt="image" src="index_files/Image_047.jpg"/></span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="text-indent: 0pt;text-align: left;"><span><img width="1119" height="7" alt="image" src="index_files/Image_048.png"/></span></p><p style="text-indent: 0pt;text-align: left;"/><p class="s2" style="padding-left: 13pt;text-indent: 0pt;line-height: 55pt;text-align: left;"><span><img width="141" height="50" alt="image" src="index_files/Image_049.jpg"/></span>        <span class="h2">组件可以访问Vue实例数据吗?</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p></li></ul></li><li><p style="padding-top: 1pt;padding-left: 33pt;text-indent: -15pt;line-height: 27pt;text-align: left;">组件是一个单独功能模块的封装：</p><ul id="l17"><li><p style="padding-left: 64pt;text-indent: -15pt;line-height: 27pt;text-align: left;">这个模块有属于自己的HTML模板，也应该有属性自己的数据data。</p></li></ul></li><li><p style="padding-top: 2pt;padding-left: 33pt;text-indent: -15pt;line-height: 28pt;text-align: left;">组件中的数据是保存在哪里呢？顶层的Vue实例中吗？</p><p style="text-indent: 0pt;text-align: left;"><span><img width="442" height="329" alt="image" src="index_files/Image_050.jpg"/></span></p><ul id="l18"><li><p style="padding-left: 64pt;text-indent: -15pt;line-height: 28pt;text-align: left;">我们先来测试一下，组件中能不能直接访问Vue实例中的data</p><p style="text-indent: 0pt;text-align: left;"><br/></p><ul id="l19"><li><p class="s7" style="padding-left: 422pt;text-indent: -19pt;line-height: 74%;text-align: left;"><span>我们发现不能访问，而且即使可以访问，如果<br/>将所有的数据都放在Vue实例中，Vue实例就会<br/>变的非常臃肿。</span></p><p style="text-indent: 0pt;text-align: left;"><span><img width="1119" height="6" alt="image" src="index_files/Image_051.png"/></span></p></li><li><p class="s7" style="padding-top: 15pt;padding-left: 422pt;text-indent: -19pt;text-align: left;">结论：Vue组件应该有自己保存数据的地方。</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="text-indent: 0pt;text-align: left;"><span><img width="1119" height="7" alt="image" src="index_files/Image_052.png"/></span></p><p style="text-indent: 0pt;text-align: left;"/><p class="s2" style="padding-left: 13pt;text-indent: 0pt;line-height: 55pt;text-align: left;"><span><img width="141" height="50" alt="image" src="index_files/Image_053.jpg"/></span>        <span class="h2">组件数据的存放</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p></li></ul></li></ul></li><li><p style="padding-top: 1pt;padding-left: 33pt;text-indent: -15pt;line-height: 27pt;text-align: left;">组件自己的数据存放在哪里呢?</p><ul id="l20"><li><p style="padding-left: 64pt;text-indent: -15pt;line-height: 26pt;text-align: left;">组件对象也有一个data属性(也可以有methods等属性，下面我们有用到)</p></li><li><p style="padding-left: 64pt;text-indent: -15pt;line-height: 26pt;text-align: left;">只是这个data属性必须是一个函数</p><p style="text-indent: 0pt;text-align: left;"><span><img width="1119" height="6" alt="image" src="index_files/Image_054.png"/></span></p></li><li><p style="padding-left: 64pt;text-indent: -15pt;line-height: 27pt;text-align: left;">而且这个函数返回一个对象，对象内部保存着数据</p><p style="padding-left: 50pt;text-indent: 0pt;text-align: left;"><span><img width="399" height="349" alt="image" src="index_files/Image_055.jpg"/></span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="text-indent: 0pt;text-align: left;"><span><img width="1119" height="7" alt="image" src="index_files/Image_056.png"/></span></p><p style="text-indent: 0pt;text-align: left;"/><p class="s2" style="padding-left: 13pt;text-indent: 0pt;line-height: 55pt;text-align: left;"><span><img width="141" height="50" alt="image" src="index_files/Image_057.jpg"/></span>        <span class="h2">为什么是一个函数呢?</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="text-indent: 0pt;text-align: left;"><span><img width="479" height="488" alt="image" src="index_files/Image_058.jpg"/></span></p></li></ul></li><li><p style="padding-top: 1pt;padding-left: 33pt;text-indent: -15pt;line-height: 27pt;text-align: justify;">为什么data在组件中必须是一个函数呢?</p><ul id="l21"><li><p style="padding-left: 64pt;text-indent: -15pt;line-height: 26pt;text-align: justify;">首先，如果不是一个函数，Vue直接就会报错。</p><p style="text-indent: 0pt;text-align: left;"><span><img width="1119" height="6" alt="image" src="index_files/Image_059.png"/></span></p></li><li><p style="padding-top: 3pt;padding-left: 64pt;text-indent: -15pt;line-height: 77%;text-align: justify;"><span>其次，原因是在于Vue让每个组件对象都返回一个新<br/>的对象，因为如果是同一个对象的，组件在多次使用<br/>后会相互影响。</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="text-indent: 0pt;text-align: left;"><span><img width="1119" height="7" alt="image" src="index_files/Image_060.png"/></span></p><p style="text-indent: 0pt;text-align: left;"/><p class="s2" style="padding-left: 13pt;text-indent: 0pt;line-height: 55pt;text-align: left;"><span><img width="141" height="50" alt="image" src="index_files/Image_061.jpg"/></span>        <span class="h2">父子组件的通信</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p></li></ul></li><li><p style="padding-top: 1pt;padding-left: 33pt;text-indent: -15pt;text-align: left;">在上一个小节中，我们提到了子组件是不能引用父组件或者Vue实例的数据的。</p></li><li><p style="padding-top: 2pt;padding-left: 33pt;text-indent: -33pt;line-height: 27pt;text-align: right;">但是，在开发中，往往一些数据确实需要从上层传递到下层：</p><ul id="l22"><li><p style="padding-left: 64pt;text-indent: -64pt;line-height: 26pt;text-align: right;">比如在一个页面中，我们从服务器请求到了很多的数据。</p></li><li><p style="padding-left: 64pt;text-indent: -15pt;line-height: 26pt;text-align: left;">其中一部分数据，并非是我们整个页面的大组件来展示的，而是需要下面的子组件进行展示。</p></li><li><p style="padding-left: 64pt;text-indent: -15pt;line-height: 27pt;text-align: left;">这个时候，并不会让子组件再次发送一个网络请求，而是直接让<b>大组件(父组件)</b>将数据传递给<b>小组件(子组件)</b>。</p><p style="text-indent: 0pt;text-align: left;"><span><img width="482" height="189" alt="image" src="index_files/Image_062.jpg"/></span></p></li></ul></li><li><p style="padding-top: 2pt;padding-left: 33pt;text-indent: -15pt;line-height: 27pt;text-align: left;">如何进行父子组件间的通信呢？Vue官方提到</p><ul id="l23"><li><p style="padding-left: 64pt;text-indent: -15pt;line-height: 26pt;text-align: left;">通过props向子组件传递数据</p></li><li><p style="padding-left: 64pt;text-indent: -15pt;line-height: 27pt;text-align: left;">通过事件向父组件发送消息</p><p style="text-indent: 0pt;text-align: left;"><br/></p></li></ul></li><li><p style="padding-left: 33pt;text-indent: -15pt;text-align: left;">在下面的代码中，我直接将Vue实例当做父组件，并且其中包含子组件来简化代码。</p><p style="text-indent: 0pt;text-align: left;"><span><img width="1119" height="6" alt="image" src="index_files/Image_063.png"/></span></p></li><li><p style="padding-top: 2pt;padding-left: 33pt;text-indent: -15pt;text-align: left;">真实的开发中，<b>Vue实例和子组件的通信</b>和<b>父组件和子组件的通信</b>过程是一样的。</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="text-indent: 0pt;text-align: left;"><span><img width="1119" height="7" alt="image" src="index_files/Image_064.png"/></span></p><p style="text-indent: 0pt;text-align: left;"/><p class="s2" style="padding-left: 13pt;text-indent: 0pt;line-height: 55pt;text-align: left;"><span><img width="141" height="50" alt="image" src="index_files/Image_065.jpg"/></span>        <span class="h2">props基本用法</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p></li><li><p style="padding-top: 1pt;padding-left: 33pt;text-indent: -15pt;text-align: left;">在组件中，使用选项props来声明需要从父级接收到的数据。</p></li><li><p style="padding-top: 2pt;padding-left: 33pt;text-indent: -15pt;line-height: 27pt;text-align: left;">props的值有两种方式：</p><ul id="l24"><li><p style="padding-left: 64pt;text-indent: -15pt;line-height: 26pt;text-align: left;">方式一：字符串数组，数组中的字符串就是传递时的名称。</p></li><li><p style="padding-left: 64pt;text-indent: -15pt;line-height: 28pt;text-align: left;">方式二：对象，对象可以设置传递时的类型，也可以设置默认值等。</p><p style="text-indent: 0pt;text-align: left;"><span><img width="1119" height="6" alt="image" src="index_files/Image_066.png"/></span></p><p style="text-indent: 0pt;text-align: left;"><span><img width="721" height="298" alt="image" src="index_files/Image_067.jpg"/></span></p></li></ul></li><li><p style="padding-top: 2pt;padding-left: 33pt;text-indent: -15pt;text-align: left;">我们先来看一个最简单的props传递：</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="text-indent: 0pt;text-align: left;"><span><img width="1119" height="7" alt="image" src="index_files/Image_068.png"/></span></p><p style="text-indent: 0pt;text-align: left;"/><p class="s2" style="padding-left: 13pt;text-indent: 0pt;line-height: 55pt;text-align: left;"><span><img width="141" height="50" alt="image" src="index_files/Image_069.jpg"/></span>        <span class="h2">props数据验证</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="text-indent: 0pt;text-align: left;"><span><img width="407" height="481" alt="image" src="index_files/Image_070.jpg"/></span></p></li><li><p style="padding-top: 1pt;padding-left: 33pt;text-indent: -15pt;text-align: left;">在前面，我们的props选项是使用一个数组。</p></li><li><p style="padding-top: 6pt;padding-left: 33pt;text-indent: -15pt;line-height: 77%;text-align: left;">我们说过，除了数组之外，我们也可以使用对象，当需要对<b>props</b>，就需要对象写法了。</p></li><li><p style="padding-top: 4pt;padding-left: 33pt;text-indent: -15pt;line-height: 27pt;text-align: left;">验证都支持哪些数据类型呢？</p><ul id="l25"><li><p style="padding-left: 64pt;text-indent: -15pt;line-height: 26pt;text-align: left;">String</p><p style="text-indent: 0pt;text-align: left;"><span><img width="334" height="180" alt="image" src="index_files/Image_071.jpg"/></span></p></li><li><p style="padding-left: 64pt;text-indent: -15pt;line-height: 26pt;text-align: left;">Number</p></li><li><p style="padding-left: 64pt;text-indent: -15pt;line-height: 26pt;text-align: left;">Boolean</p></li><li><p style="padding-left: 64pt;text-indent: -15pt;line-height: 26pt;text-align: left;">Array</p></li><li><p style="padding-left: 64pt;text-indent: -15pt;line-height: 26pt;text-align: left;">Object</p></li><li><p style="padding-left: 64pt;text-indent: -15pt;line-height: 26pt;text-align: left;">Date</p></li><li><p style="padding-left: 64pt;text-indent: -15pt;line-height: 26pt;text-align: left;">Function</p></li><li><p style="padding-left: 64pt;text-indent: -15pt;line-height: 27pt;text-align: left;">Symbol</p><p style="text-indent: 0pt;text-align: left;"><span><img width="1119" height="6" alt="image" src="index_files/Image_072.png"/></span></p></li></ul></li><li><p style="padding-top: 2pt;padding-left: 33pt;text-indent: -15pt;text-align: left;">当我们有自定义构造函数时，验证也支持自定义的类型</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="text-indent: 0pt;text-align: left;"><span><img width="1119" height="7" alt="image" src="index_files/Image_073.png"/></span></p><p style="text-indent: 0pt;text-align: left;"/><p class="s2" style="padding-left: 13pt;text-indent: 0pt;line-height: 55pt;text-align: left;"><span><img width="141" height="50" alt="image" src="index_files/Image_074.jpg"/></span>        <span class="h2">子级向父级传递</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p></li><li><p style="padding-top: 1pt;padding-left: 33pt;text-indent: -15pt;text-align: left;">props用于父组件向子组件传递数据，还有一种比较常见的是子组件传递数据或事件到父组件中。</p></li><li><p style="padding-top: 2pt;padding-left: 33pt;text-indent: -15pt;text-align: left;">我们应该如何处理呢？这个时候，我们需要使用<b>自定义事件</b>来完成。</p></li><li><p style="padding-top: 2pt;padding-left: 33pt;text-indent: -15pt;line-height: 27pt;text-align: left;">什么时候需要自定义事件呢？</p><ul id="l26"><li><p style="padding-left: 64pt;text-indent: -15pt;line-height: 26pt;text-align: left;">当子组件需要向父组件传递数据时，就要用到自定义事件了。</p></li><li><p style="padding-left: 64pt;text-indent: -15pt;line-height: 27pt;text-align: left;">我们之前学习的v-on不仅仅可以用于监听DOM事件，也可以用于组件间的自定义事件。</p></li></ul></li><li><p style="padding-top: 2pt;padding-left: 33pt;text-indent: -15pt;line-height: 27pt;text-align: left;">自定义事件的流程：</p><ul id="l27"><li><p style="padding-left: 64pt;text-indent: -15pt;line-height: 26pt;text-align: left;">在子组件中，通过$emit()来触发事件。</p></li><li><p style="padding-left: 64pt;text-indent: -15pt;line-height: 27pt;text-align: left;">在父组件中，通过v-on来监听子组件事件。</p></li></ul></li><li><p style="padding-top: 2pt;padding-left: 33pt;text-indent: -15pt;line-height: 27pt;text-align: left;">我们来看一个简单的例子：</p><ul id="l28"><li><p style="padding-left: 64pt;text-indent: -15pt;line-height: 26pt;text-align: left;">我们之前做过一个两个按钮+1和-1，点击后修改counter。</p></li><li><p style="padding-left: 64pt;text-indent: -15pt;line-height: 26pt;text-align: left;">我们整个操作的过程还是在子组件中完成，但是之后的展示交给父组件。</p><p style="text-indent: 0pt;text-align: left;"><span><img width="1119" height="6" alt="image" src="index_files/Image_075.png"/></span></p></li><li><p style="padding-left: 64pt;text-indent: -15pt;line-height: 27pt;text-align: left;">这样，我们就需要将子组件中的counter，传给父组件的某个属性，比如total。</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="text-indent: 0pt;text-align: left;"><span><img width="1119" height="7" alt="image" src="index_files/Image_076.png"/></span></p><p style="text-indent: 0pt;text-align: left;"><span><img width="1119" height="6" alt="image" src="index_files/Image_077.png"/></span></p><p style="text-indent: 0pt;text-align: left;"/><p class="s2" style="padding-left: 13pt;text-indent: 0pt;line-height: 55pt;text-align: left;"><span><img width="141" height="50" alt="image" src="index_files/Image_078.jpg"/></span>        <span class="h2">自定义事件代码</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 43pt;text-indent: 0pt;text-align: left;"><span><img width="1002" height="500" alt="image" src="index_files/Image_079.png"/></span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="text-indent: 0pt;text-align: left;"><span><img width="1119" height="7" alt="image" src="index_files/Image_080.png"/></span></p><p style="text-indent: 0pt;text-align: left;"/><p class="s2" style="padding-left: 13pt;text-indent: 0pt;line-height: 55pt;text-align: left;"><span><img width="141" height="50" alt="image" src="index_files/Image_081.jpg"/></span>        <span class="h2">父子组件的访问方式： $children</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="text-indent: 0pt;text-align: left;"><span><img width="654" height="424" alt="image" src="index_files/Image_082.jpg"/></span></p></li></ul></li><li><p style="padding-top: 6pt;padding-left: 33pt;text-indent: -15pt;line-height: 77%;text-align: justify;"><span>有时候我们需要父组件直接访问子组件，<br/>子组件直接访问父组件，或者是子组件访<br/>问跟组件。</span></p><ul id="l29"><li><p style="padding-left: 64pt;text-indent: -15pt;line-height: 25pt;text-align: justify;">父组件访问子组件：使用$children或</p><p class="s8" style="padding-left: 64pt;text-indent: 0pt;line-height: 24pt;text-align: justify;">$refs <span class="p">reference(引用)</span></p></li><li><p style="padding-left: 64pt;text-indent: -15pt;line-height: 27pt;text-align: justify;">子组件访问父组件：使用$parent</p><p style="text-indent: 0pt;text-align: left;"><br/></p></li></ul></li><li><p style="padding-left: 33pt;text-indent: -15pt;line-height: 28pt;text-align: left;">我们先来看下$children的访问</p><ul id="l30"><li><p style="padding-top: 3pt;padding-left: 64pt;text-indent: -15pt;line-height: 76%;text-align: left;"><span>this.$children是一个数组类型，它包<br/>含所有子组件对象。</span></p><p style="text-indent: 0pt;text-align: left;"><span><img width="1119" height="6" alt="image" src="index_files/Image_083.png"/></span></p></li><li><p style="padding-top: 4pt;padding-left: 64pt;text-indent: -15pt;line-height: 77%;text-align: left;"><span>我们这里通过一个遍历，取出所有子<br/>组件的message状态。</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="text-indent: 0pt;text-align: left;"><span><img width="1119" height="7" alt="image" src="index_files/Image_084.png"/></span></p><p style="text-indent: 0pt;text-align: left;"/><p class="s2" style="padding-left: 13pt;text-indent: 0pt;line-height: 55pt;text-align: left;"><span><img width="141" height="50" alt="image" src="index_files/Image_085.jpg"/></span>        <span class="h2">父子组件的访问方式： $refs</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p></li></ul></li><li><p style="padding-top: 1pt;padding-left: 33pt;text-indent: -15pt;line-height: 27pt;text-align: left;">$children的缺陷：</p><ul id="l31"><li><p style="padding-left: 64pt;text-indent: -15pt;line-height: 26pt;text-align: left;">通过$children访问子组件时，是一个数组类型，访问其中的子组件必须通过索引值。</p></li><li><p style="padding-left: 64pt;text-indent: -15pt;line-height: 26pt;text-align: left;">但是当子组件过多，我们需要拿到其中一个时，往往不能确定它的索引值，甚至还可能会发生变化。</p></li><li><p style="padding-left: 64pt;text-indent: -15pt;line-height: 27pt;text-align: left;">有时候，我们想明确获取其中一个特定的组件，这个时候就可以使用$refs</p></li></ul></li><li><p style="padding-top: 2pt;padding-left: 33pt;text-indent: -15pt;line-height: 27pt;text-align: left;">$refs的使用：</p><ul id="l32"><li><p style="padding-left: 64pt;text-indent: -15pt;line-height: 26pt;text-align: left;">$refs和ref指令通常是一起使用的。</p></li><li><p style="padding-left: 64pt;text-indent: -15pt;line-height: 26pt;text-align: left;">首先，我们通过ref给某一个子组件绑定一个特定的ID。</p><p style="text-indent: 0pt;text-align: left;"><span><img width="1119" height="6" alt="image" src="index_files/Image_086.png"/></span></p></li><li><p style="padding-left: 64pt;text-indent: -15pt;line-height: 27pt;text-align: left;">其次，通过this.$refs.ID就可以访问到该组件了。</p><p style="padding-left: 52pt;text-indent: 0pt;text-align: left;"><span><img width="681" height="90" alt="image" src="index_files/Image_087.jpg"/></span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 52pt;text-indent: 0pt;text-align: left;"><span><img width="560" height="104" alt="image" src="index_files/Image_088.jpg"/></span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="text-indent: 0pt;text-align: left;"><span><img width="1119" height="7" alt="image" src="index_files/Image_089.png"/></span></p><p style="text-indent: 0pt;text-align: left;"/><p class="s2" style="padding-left: 13pt;text-indent: 0pt;line-height: 55pt;text-align: left;"><span><img width="141" height="50" alt="image" src="index_files/Image_090.jpg"/></span>        <span class="h2">父子组件的访问方式： $parent</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="text-indent: 0pt;text-align: left;"><span><img width="639" height="416" alt="image" src="index_files/Image_091.jpg"/></span></p></li></ul></li><li><p class="s3" style="padding-top: 4pt;padding-left: 33pt;text-indent: -15pt;line-height: 85%;text-align: left;"><span>如果我们想在子组件中直接访问父组件，可以通<br/>过$parent</span></p></li><li><p class="s3" style="padding-top: 5pt;padding-left: 33pt;text-indent: -15pt;text-align: left;">注意事项：</p><ul id="l33"><li><p class="s3" style="padding-top: 3pt;padding-left: 64pt;text-indent: -15pt;line-height: 85%;text-align: left;"><span>尽管在Vue开发中，我们允许通过$parent<br/>来访问父组件，但是在真实开发中尽量不要                                                                       <br/>这样做。</span></p></li><li><p class="s3" style="padding-top: 4pt;padding-left: 64pt;text-indent: -15pt;line-height: 85%;text-align: left;"><span>子组件应该尽量避免直接访问父组件的数据，<br/>因为这样耦合度太高了。</span></p></li><li><p class="s3" style="padding-top: 4pt;padding-left: 64pt;text-indent: -15pt;line-height: 85%;text-align: justify;"><span>如果我们将子组件放在另外一个组件之内，<br/>很可能该父组件没有对应的属性，往往会引 <br/>起问题。</span></p><p style="text-indent: 0pt;text-align: left;"><span><img width="1119" height="6" alt="image" src="index_files/Image_092.png"/></span></p></li><li><p class="s3" style="padding-top: 4pt;padding-left: 64pt;text-indent: -15pt;line-height: 85%;text-align: justify;"><span>另外，更不好做的是通过$parent直接修改<br/>父组件的状态，那么父组件中的状态将变得 <br/>飘忽不定，很不利于我的调试和维护。</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="text-indent: 0pt;text-align: left;"><span><img width="1119" height="7" alt="image" src="index_files/Image_093.png"/></span></p><p style="text-indent: 0pt;text-align: left;"/><p class="s2" style="padding-left: 13pt;text-indent: 0pt;line-height: 55pt;text-align: left;"><span><img width="141" height="50" alt="image" src="index_files/Image_094.jpg"/></span>        <span class="h2">非父子组件通信</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p></li></ul></li><li><p style="padding-top: 1pt;padding-left: 33pt;text-indent: -15pt;line-height: 27pt;text-align: left;">刚才我们讨论的都是父子组件间的通信，那如果是非父子关系呢?</p><ul id="l34"><li><p style="padding-left: 64pt;text-indent: -15pt;line-height: 27pt;text-align: left;">非父子组件关系包括多个层级的组件，也包括兄弟组件的关系。</p></li></ul></li><li><p style="padding-top: 2pt;padding-left: 33pt;text-indent: -15pt;line-height: 28pt;text-align: left;">在Vue1.x的时候，可以通过$dispatch和$broadcast完成</p><ul id="l35"><li><p style="padding-left: 64pt;text-indent: -15pt;line-height: 26pt;text-align: left;">$dispatch用于向上级派发事件</p></li><li><p style="padding-left: 64pt;text-indent: -15pt;line-height: 26pt;text-align: left;">$broadcast用于向下级广播事件</p></li><li><p style="padding-left: 64pt;text-indent: -15pt;line-height: 27pt;text-align: left;">但是在Vue2.x都被取消了</p></li></ul></li><li><p style="padding-top: 2pt;padding-left: 33pt;text-indent: -15pt;line-height: 27pt;text-align: left;">在Vue2.x中，有一种方案是通过<b>中央事件总线</b>，也就是一个中介来完成。</p><ul id="l36"><li><p style="padding-left: 64pt;text-indent: -15pt;line-height: 26pt;text-align: left;">但是这种方案和直接使用Vuex的状态管理方案还是逊色很多。</p><p style="text-indent: 0pt;text-align: left;"><span><img width="1119" height="6" alt="image" src="index_files/Image_095.png"/></span></p></li><li><p style="padding-left: 64pt;text-indent: -15pt;line-height: 27pt;text-align: left;">并且Vuex提供了更多好用的功能，所以这里我们暂且不讨论这种方案，后续我们专门学习Vuex的状态管理。</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="text-indent: 0pt;text-align: left;"><span><img width="1119" height="7" alt="image" src="index_files/Image_096.png"/></span></p><p style="text-indent: 0pt;text-align: left;"/><p class="s2" style="padding-left: 13pt;text-indent: 0pt;line-height: 55pt;text-align: left;"><span><img width="141" height="50" alt="image" src="index_files/Image_097.jpg"/></span>        <span class="h2">为什么使用slot</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p></li></ul></li><li><p style="padding-top: 1pt;padding-left: 33pt;text-indent: -15pt;line-height: 27pt;text-align: left;">slot翻译为插槽：</p><ul id="l37"><li><p style="padding-left: 64pt;text-indent: -15pt;line-height: 26pt;text-align: left;">在生活中很多地方都有插槽，电脑的USB插槽，插板当中的电源插槽。</p></li><li><p style="padding-left: 64pt;text-indent: -15pt;line-height: 26pt;text-align: left;">插槽的目的是让我们原来的设备具备更多的扩展性。</p></li><li><p style="padding-left: 64pt;text-indent: -15pt;line-height: 27pt;text-align: left;">比如电脑的USB我们可以插入U盘、硬盘、手机、音响、键盘、鼠标等等。</p></li></ul></li><li><p style="padding-top: 2pt;padding-left: 33pt;text-indent: -15pt;line-height: 27pt;text-align: left;">组件的插槽：</p><ul id="l38"><li><p style="padding-left: 64pt;text-indent: -15pt;line-height: 24pt;text-align: left;">组件的插槽也是为了让我们封装的组件更加具有扩展性。</p></li><li><p style="padding-left: 64pt;text-indent: -15pt;line-height: 30pt;text-align: left;">让使用者可以决定组件内部的一些内容到底展示什么。 <span><img width="332" height="40" alt="image" src="index_files/Image_098.jpg"/></span></p><p style="text-indent: 0pt;text-align: left;"><span><img width="330" height="42" alt="image" src="index_files/Image_099.jpg"/></span></p></li></ul></li><li><p style="padding-top: 2pt;padding-left: 33pt;text-indent: -15pt;line-height: 27pt;text-align: left;">栗子：移动网站中的导航栏。</p><ul id="l39"><li><p style="padding-left: 64pt;text-indent: -15pt;line-height: 26pt;text-align: left;">移动开发中，几乎每个页面都有导航栏。</p><p style="text-indent: 0pt;text-align: left;"><span><img width="339" height="46" alt="image" src="index_files/Image_100.jpg"/></span></p></li><li><p style="padding-left: 64pt;text-indent: -15pt;line-height: 26pt;text-align: left;">导航栏我们必然会封装成一个插件，比如nav-bar组件。</p></li><li><p style="padding-left: 64pt;text-indent: -15pt;line-height: 28pt;text-align: left;">一旦有了这个组件，我们就可以在多个页面中复用了。</p><p style="text-indent: 0pt;text-align: left;"><span><img width="1119" height="6" alt="image" src="index_files/Image_101.png"/></span></p><p style="text-indent: 0pt;text-align: left;"><span><img width="339" height="46" alt="image" src="index_files/Image_102.jpg"/></span></p></li></ul></li><li><p style="padding-top: 2pt;padding-left: 33pt;text-indent: -15pt;text-align: left;">但是，每个页面的导航是一样的吗？No，我以京东M站为例</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="text-indent: 0pt;text-align: left;"><span><img width="1119" height="7" alt="image" src="index_files/Image_103.png"/></span></p><p style="text-indent: 0pt;text-align: left;"/><p class="s2" style="padding-left: 13pt;text-indent: 0pt;line-height: 55pt;text-align: left;"><span><img width="141" height="50" alt="image" src="index_files/Image_104.jpg"/></span>        <span class="h2">如何封装这类组件呢？slot</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p></li><li><p style="padding-top: 1pt;padding-left: 33pt;text-indent: -15pt;line-height: 27pt;text-align: left;">如何去封装这类的组件呢？</p><ul id="l40"><li><p style="padding-left: 64pt;text-indent: -15pt;line-height: 26pt;text-align: left;">它们也很多区别，但是也有很多共性。</p></li><li><p style="padding-left: 64pt;text-indent: -15pt;line-height: 26pt;text-align: left;">如果，我们每一个单独去封装一个组件，显然不合适：比如每个页面都返回，这部分内容我们就要重复去封装。</p></li><li><p style="padding-top: 3pt;padding-left: 64pt;text-indent: -15pt;line-height: 77%;text-align: left;"><span>但是，如果我们封装成一个，好像也不合理：有些左侧是菜单，有些是返回，有些中间是搜索，有些是文字，<br/>等等。</span></p></li></ul></li><li><p style="padding-top: 3pt;padding-left: 33pt;text-indent: -15pt;line-height: 27pt;text-align: left;">如何封装合适呢？抽取共性，保留不同。</p><ul id="l41"><li><p style="padding-left: 64pt;text-indent: -15pt;line-height: 26pt;text-align: left;">最好的封装方式就是将共性抽取到组件中，将不同暴露为插槽。</p></li><li><p style="padding-left: 64pt;text-indent: -15pt;line-height: 26pt;text-align: left;">一旦我们预留了插槽，就可以让使用者根据自己的需求，决定插槽中插入什么内容。</p></li><li><p style="padding-left: 64pt;text-indent: -15pt;line-height: 27pt;text-align: left;">是搜索框，还是文字，还是菜单。由调用者自己来决定。</p><p style="text-indent: 0pt;text-align: left;"><span><img width="1119" height="6" alt="image" src="index_files/Image_105.png"/></span></p></li></ul></li><li><p style="padding-top: 2pt;padding-left: 33pt;text-indent: -15pt;text-align: left;">这就是为什么我们要学习组件中的插槽slot的原因。</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="text-indent: 0pt;text-align: left;"><span><img width="1119" height="7" alt="image" src="index_files/Image_106.png"/></span></p><p style="text-indent: 0pt;text-align: left;"/><p class="s2" style="padding-left: 13pt;text-indent: 0pt;line-height: 55pt;text-align: left;"><span><img width="141" height="50" alt="image" src="index_files/Image_107.jpg"/></span>        <span class="h2">slot基本使用</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p></li><li><p style="padding-top: 1pt;padding-left: 33pt;text-indent: -15pt;line-height: 27pt;text-align: left;">了解了为什么用slot，我们再来谈谈如何使用slot？</p><ul id="l42"><li><p style="padding-left: 64pt;text-indent: -15pt;line-height: 26pt;text-align: left;">在子组件中，使用特殊的元素&lt;slot&gt;就可以为子组件开启一个插槽。</p></li><li><p style="padding-left: 64pt;text-indent: -15pt;line-height: 27pt;text-align: left;">该插槽插入什么内容取决于父组件如何使用。</p></li></ul></li><li><p style="padding-top: 2pt;padding-left: 33pt;text-indent: -15pt;line-height: 27pt;text-align: left;">我们通过一个简单的例子，来给子组件定义一个插槽：</p><ul id="l43"><li><p style="padding-left: 64pt;text-indent: -15pt;line-height: 26pt;text-align: left;">&lt;slot&gt;中的内容表示，如果没有在该组件中插入任何其他内容，就默认显示该内容</p><p style="text-indent: 0pt;text-align: left;"><span><img width="1119" height="6" alt="image" src="index_files/Image_108.png"/></span></p></li><li><p style="padding-bottom: 2pt;padding-left: 64pt;text-indent: -15pt;line-height: 27pt;text-align: left;">有了这个插槽后，父组件如何使用呢？</p><p class="s6" style="padding-left: 50pt;text-indent: 0pt;text-align: left;"><span><img width="334" height="262" alt="image" src="index_files/Image_109.jpg"/></span>	<span><img width="555" height="156" alt="image" src="index_files/Image_110.jpg"/></span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="text-indent: 0pt;text-align: left;"><span><img width="1119" height="7" alt="image" src="index_files/Image_111.png"/></span></p><p class="s2" style="padding-left: 13pt;text-indent: 0pt;line-height: 55pt;text-align: left;"><span><img width="141" height="50" alt="image" src="index_files/Image_112.jpg"/></span>        <span class="h2">具名插槽slot</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="text-indent: 0pt;text-align: left;"><span><img width="317" height="276" alt="image" src="index_files/Image_113.jpg"/></span><span><img width="450" height="231" alt="image" src="index_files/Image_114.jpg"/></span></p></li></ul></li><li><p style="padding-top: 1pt;padding-left: 33pt;text-indent: -15pt;line-height: 27pt;text-align: left;">当子组件的功能复杂时，子组件的插槽可能并非是一个。</p><ul id="l44"><li><p style="padding-top: 3pt;padding-left: 64pt;text-indent: -15pt;line-height: 76%;text-align: left;"><span>比如我们封装一个导航栏的子组件，可能就需要三个插<br/>槽，分别代表左边、中间、右边。</span></p></li><li><p style="padding-top: 4pt;padding-left: 64pt;text-indent: -15pt;line-height: 76%;text-align: left;"><span>那么，外面在给插槽插入内容时，如何区分插入的是哪<br/>一个呢？</span></p></li><li><p style="padding-left: 64pt;text-indent: -15pt;line-height: 28pt;text-align: left;">这个时候，我们就需要给插槽起一个名字</p></li></ul></li><li><p style="padding-top: 2pt;padding-left: 33pt;text-indent: -15pt;line-height: 27pt;text-align: left;">如何使用具名插槽呢？</p><ul id="l45"><li><p style="padding-left: 64pt;text-indent: -15pt;line-height: 26pt;text-align: left;">非常简单，只要给slot元素一个name属性即可</p></li><li><p style="padding-left: 64pt;text-indent: -15pt;line-height: 28pt;text-align: left;">&lt;slot name=&#39;myslot&#39;&gt;&lt;/slot&gt;</p></li></ul></li><li><p style="padding-top: 2pt;padding-left: 33pt;text-indent: -15pt;line-height: 27pt;text-align: left;">我们来给出一个案例：</p><p style="text-indent: 0pt;text-align: left;"><span><img width="1119" height="6" alt="image" src="index_files/Image_115.png"/></span></p><ul id="l46"><li><p style="padding-top: 3pt;padding-left: 64pt;text-indent: -15pt;line-height: 77%;text-align: left;"><span>这里我们先不对导航组件做非常复杂的封装，先了解具<br/>名插槽的用法。</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="text-indent: 0pt;text-align: left;"><span><img width="1119" height="7" alt="image" src="index_files/Image_116.png"/></span></p><p style="text-indent: 0pt;text-align: left;"/><p class="s2" style="padding-left: 13pt;text-indent: 0pt;line-height: 55pt;text-align: left;"><span><img width="141" height="50" alt="image" src="index_files/Image_117.jpg"/></span>        <span class="h2">编译作用域</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="text-indent: 0pt;text-align: left;"><span><img width="428" height="464" alt="image" src="index_files/Image_118.jpg"/></span></p></li></ul></li><li><p class="s9" style="padding-top: 1pt;padding-left: 33pt;text-indent: -15pt;text-align: left;">在真正学习插槽之前，我们需要先理解一个概念：编译作用域。</p></li><li><p class="s9" style="padding-top: 6pt;padding-left: 33pt;text-indent: -15pt;text-align: left;">官方对于编译的作用域解析比较简单，我们自己来通过一个例子来理解这个概念：</p></li><li><p class="s9" style="padding-top: 6pt;padding-left: 33pt;text-indent: -15pt;text-align: left;">我们来考虑下面的代码是否最终是可以渲染出来的：</p><ul id="l47"><li><p class="s9" style="padding-top: 2pt;padding-left: 64pt;text-indent: -15pt;text-align: left;">&lt;my-cpn v-show=&quot;isShow&quot;&gt;&lt;/my-cpn&gt;中，我们使用了isShow属性。</p></li><li><p class="s9" style="padding-top: 2pt;padding-left: 64pt;text-indent: -15pt;text-align: left;">isShow属性包含在组件中，也包含在Vue实例中。</p></li></ul></li><li><p class="s9" style="padding-top: 6pt;padding-left: 33pt;text-indent: -15pt;text-align: left;">答案：最终可以渲染出来，也就是使用的是Vue实例的属性。</p></li><li><p class="s9" style="padding-top: 6pt;padding-left: 33pt;text-indent: -15pt;text-align: left;">为什么呢？</p><ul id="l48"><li><p class="s9" style="padding-top: 3pt;padding-left: 64pt;text-indent: -15pt;line-height: 92%;text-align: left;">官方给出了一条准则：<b>父组件模板的所有东西都会在父级作用域内编译；子</b></p></li><li><p class="s9" style="padding-top: 4pt;padding-left: 64pt;text-indent: -15pt;line-height: 92%;text-align: left;"><span>而我们在使用&lt;my-cpn v-show=&quot;isShow&quot;&gt;&lt;/my-cpn&gt;的时候，整个组<br/>件的使用过程是相当于在父组件中出现的。</span></p></li><li><p class="s9" style="padding-top: 2pt;padding-left: 64pt;text-indent: -15pt;text-align: left;">那么他的作用域就是父组件，使用的属性也是属于父组件的属性。</p><p style="text-indent: 0pt;text-align: left;"><span><img width="1119" height="6" alt="image" src="index_files/Image_119.png"/></span></p></li><li><p class="s9" style="padding-top: 2pt;padding-left: 64pt;text-indent: -15pt;text-align: left;">因此，isShow使用的是Vue实例中的属性，而不是子组件的属性。</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="text-indent: 0pt;text-align: left;"><span><img width="1119" height="7" alt="image" src="index_files/Image_120.png"/></span></p><p style="text-indent: 0pt;text-align: left;"/><p class="s2" style="padding-left: 13pt;text-indent: 0pt;line-height: 55pt;text-align: left;"><span><img width="141" height="50" alt="image" src="index_files/Image_121.jpg"/></span>        <span class="h2">作用域插槽：准备</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p></li></ul></li><li><p style="padding-top: 1pt;padding-left: 33pt;text-indent: -15pt;text-align: left;">作用域插槽是slot一个比较难理解的点，而且官方文档说的又有点不清晰。</p></li><li><p style="padding-top: 2pt;padding-left: 33pt;text-indent: -15pt;line-height: 27pt;text-align: left;">这里，我们用一句话对其做一个总结，然后我们在后续的案例中来体会：</p><ul id="l49"><li><p style="padding-left: 64pt;text-indent: -15pt;line-height: 27pt;text-align: left;">父组件替换插槽的标签，但是内容由子组件来提供。</p></li></ul></li><li><p style="padding-top: 2pt;padding-left: 33pt;text-indent: -15pt;line-height: 27pt;text-align: left;">我们先提一个需求：</p><ul id="l50"><li><p style="padding-left: 64pt;text-indent: -15pt;line-height: 26pt;text-align: left;">子组件中包括一组数据，比如：pLanguages: [&#39;JavaScript&#39;, &#39;Python&#39;, &#39;Swift&#39;, &#39;Go&#39;, &#39;C++&#39;]</p><p style="text-indent: 0pt;text-align: left;"><span><img width="454" height="286" alt="image" src="index_files/Image_122.jpg"/></span></p></li><li><p style="padding-left: 64pt;text-indent: -15pt;line-height: 26pt;text-align: left;">需要在多个界面进行展示：</p><ul id="l51"><li><p style="padding-left: 96pt;text-indent: -15pt;line-height: 26pt;text-align: left;">某些界面是以水平方向一一展示的，</p></li><li><p style="padding-left: 96pt;text-indent: -15pt;line-height: 26pt;text-align: left;">某些界面是以列表形式展示的，</p></li><li><p style="padding-left: 96pt;text-indent: -15pt;line-height: 26pt;text-align: left;">某些界面直接展示一个数组</p></li></ul></li><li><p style="padding-left: 64pt;text-indent: -15pt;line-height: 26pt;text-align: left;">内容在子组件，希望父组件告诉我们如何展示，怎么办呢？</p><ul id="l52"><li><p style="padding-left: 96pt;text-indent: -15pt;line-height: 28pt;text-align: left;">利用slot作用域插槽就可以了</p></li></ul><p style="text-indent: 0pt;text-align: left;"><span><img width="1119" height="6" alt="image" src="index_files/Image_123.png"/></span></p></li></ul></li><li><p style="padding-top: 2pt;padding-left: 33pt;text-indent: -15pt;text-align: left;">我们来看看子组件的定义：</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="text-indent: 0pt;text-align: left;"><span><img width="1119" height="7" alt="image" src="index_files/Image_124.png"/></span></p><p style="text-indent: 0pt;text-align: left;"/><p class="s2" style="padding-left: 13pt;text-indent: 0pt;line-height: 55pt;text-align: left;"><span><img width="141" height="50" alt="image" src="index_files/Image_125.jpg"/></span>        <span class="h2">作用域插槽：使用</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p></li><li><p style="padding-top: 1pt;padding-left: 33pt;text-indent: -15pt;line-height: 27pt;text-align: left;">在父组件使用我们的子组件时，从子组件中拿到数据：</p><ul id="l53"><li><p style="padding-left: 64pt;text-indent: -15pt;line-height: 26pt;text-align: left;">我们通过&lt;template slot-scope=&quot;slotProps&quot;&gt;获取到slotProps属性</p><p style="text-indent: 0pt;text-align: left;"><span><img width="1119" height="6" alt="image" src="index_files/Image_126.png"/></span></p></li><li><p style="padding-bottom: 3pt;padding-left: 64pt;text-indent: -15pt;line-height: 27pt;text-align: left;">在通过slotProps.data就可以获取到刚才我们传入的data了</p></li></ul></li></ul><p style="padding-left: 51pt;text-indent: 0pt;text-align: left;"><span><img width="853" height="363" alt="image" src="index_files/Image_127.jpg"/></span></p></body></html>
